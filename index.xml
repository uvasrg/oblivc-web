<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Obliv-C</title>
    <link>//oblivc.org/index.xml</link>
    <description>Recent content on Obliv-C</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 06 Jul 2017 16:05:58 -0400</lastBuildDate>
    <atom:link href="//oblivc.org/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Obliv-C - Documentation</title>
      <link>//oblivc.org/documentation/</link>
      <pubDate>Thu, 06 Jul 2017 16:05:58 -0400</pubDate>
      
      <guid>//oblivc.org/documentation/</guid>
      <description>

&lt;h4 id=&#34;about-this-documentation&#34;&gt;About this Documentation&lt;/h4&gt;

&lt;p&gt;This documention is provided to make the Obliv-C API simpler for users to understand in order to write programs in Obliv-C successfully, and uses  an informal tone to achieve this purpose. For a more formal introduction to Obliv-C, read &lt;a href=&#34;http://eprint.iacr.org/2015/1153.pdf&#34;&gt;&lt;em&gt;Obliv-C: A Language for Extensible
Data-Oblivious Computation&lt;/em&gt;&lt;/a&gt;.  For getting started quickly programming with Obliv-C, we recommend using the &lt;a href=&#34;../tutorial&#34;&gt;tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;font size=&#34;-1&#34;&gt;This documentation is generated from &lt;a href=&#34;https://github.com/uvasrg/oblivc-web/&#34;&gt;https://github.com/uvasrg/oblivc-web/&lt;/a&gt;; please submit an Issue or PR if you have suggestions on improving it.&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Obliv-C was designed to provide a convenient bridge between users of secure computation protocols and protocol developers. Programmers who want to use secure computation, but are not experts in cryptography, should be able to use it easily and securely. On the other hand, experts should be able to provide extra primitives as simple library functions without having to invent a full language/compiler from scratch. This is intended to rectify the current situation where a new language needs to be invented every time someone decides to develop a new cryptographic protocol (e.g., ORAM for random access, private set intersection protocols, or protocols for other adversarial models). This way researchers can test new cryptographic techniques without having to be experts in language design/compilers.&lt;/p&gt;

&lt;p&gt;The way this language is supposed to be used is as follows: we start with a code written in this Obliv-C, a strict extension of standard C. All parties agree to execute this program in a secure execution protocol, where most inputs are private, and only the output of the computation are to be revealed to all (or some) parties. The intermediate results stay hidden, protected by the underlying cryptographic protocols.&lt;/p&gt;

&lt;h2 id=&#34;oblivious-types&#34;&gt;Oblivious Types&lt;/h2&gt;

&lt;h3 id=&#34;the-obliv-qualifier&#34;&gt;The &lt;code&gt;obliv&lt;/code&gt; qualifier&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;obliv&lt;/code&gt; qualifier should be declared on any variable that is
supposed to depend on unknown inputs in any way; &lt;code&gt;obliv&lt;/code&gt;-qualified
values implement secure encryption on the variable, and can only be
declared in an Obliv-C file (&lt;code&gt;.oc&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Supported data types for the &lt;code&gt;obliv&lt;/code&gt; qualifier are &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;,
&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, and &lt;code&gt;float&lt;/code&gt;. Non-obliv values
can be implicitly converted into &lt;code&gt;obliv&lt;/code&gt;, but &lt;code&gt;obliv&lt;/code&gt; values cannot be
implicitly converted to non-obliv. Doing this requires
&lt;code&gt;revealObliv&amp;lt;Tname&amp;gt;()&lt;/code&gt; (described below) to be called to indicate that
previously-oblivious data is now being revealed.&lt;/p&gt;

&lt;h2 id=&#34;control-structures&#34;&gt;Control Structures&lt;/h2&gt;

&lt;p&gt;For oblivious execution, program control can never depend on &lt;code&gt;obliv&lt;/code&gt; values, which are not (semantically) accessible to the execution. In general, we cannot hide the length of time a protocol takes to run, and in the same vein, the number of iterations of a loop is also known to all parties (since they are all executing the protocol). Hence, Obliv-C will not allow an &lt;code&gt;obliv&lt;/code&gt; variable to be ever used in the condition of any existing control structure (e.g., &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, etc.).&lt;/p&gt;

&lt;h3 id=&#34;oblivious-conditionals-obliv-if&#34;&gt;Oblivious conditionals: &lt;code&gt;obliv if&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The new control structure ‘obliv if’ can be used with &lt;code&gt;obliv&lt;/code&gt; values in the predicate. Its syntax is exactly like the normal if structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obliv if(...) {
  ...
} else obliv if(...) {
  ...
} else {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This control structure allows you to use &lt;code&gt;obliv&lt;/code&gt; variables in if conditions, and works a lot like normal if blocks.&lt;/p&gt;

&lt;p&gt;However, while it allows you to use obliv variables as a condition, you must realize some obvious differences. For one, during execution, it is not known (to the system executing this program) if the condition is true or not &amp;mdash; that is the whole point of &lt;code&gt;obliv&lt;/code&gt;-qualified variables. So the blocks will be actually executed &lt;em&gt;regardless&lt;/em&gt; of the condition: it doesn’t matter if the condition is true or not. So consider this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obliv int x, y;
...
obliv if (x &amp;gt; 0) y = 4;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The body of the &lt;code&gt;obliv if&lt;/code&gt; will be executed regardless of whether &lt;code&gt;x&lt;/code&gt; is positive or not. However, none of the parties would know if their execution actually changed the value of &lt;code&gt;y&lt;/code&gt; or not. If &lt;code&gt;x&lt;/code&gt; was positive, &lt;code&gt;y&lt;/code&gt; is now 4 after this is executed. If not, &lt;code&gt;y&lt;/code&gt; still has the same value as before. But the actual value of &lt;code&gt;y&lt;/code&gt; is stored encrypted in the circuit, and unknown to the executions. The assignment operation simply has no impact on the semantic value of &lt;code&gt;y&lt;/code&gt; if the condition is false.&lt;/p&gt;

&lt;p&gt;While &lt;code&gt;obliv if&lt;/code&gt; allows you to use &lt;code&gt;obliv&lt;/code&gt; variables in a condition, it does come with its own set of restrictions. For example, this is not allowed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int x=0;
obliv int y;
obliv if (y &amp;gt; 0) x = 1; // error x is not obliv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In general, inside a given &lt;code&gt;obliv if&lt;/code&gt; context, the program cannot modify any non-obliv variable that was declared outside the block, since that would betray the value of obliv condition.&lt;/p&gt;

&lt;p&gt;If you find yourself wanting to do this, you probably want &lt;code&gt;x&lt;/code&gt; to be
an &lt;code&gt;obliv int&lt;/code&gt; in the first place. (If you really want to do this, you
can escape the type system using &lt;code&gt;~obliv&lt;/code&gt; to create an unconditional
segment.)&lt;/p&gt;

&lt;p&gt;However, this is legal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obliv if (...) {
  for (int i = 0; i &amp;lt; n; i++) { … }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even though both &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are non-obliv, this is okay, since &lt;code&gt;i&lt;/code&gt; was declared inside the &lt;code&gt;obliv if&lt;/code&gt; block and &lt;code&gt;n&lt;/code&gt; is never modified. The requirement is that any changes made to non-obliv variables while inside an oblivious conditional scope are never visible from the outside.&lt;/p&gt;

&lt;p&gt;Control statements like &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;goto&lt;/code&gt;, and
case labels, etc. cannot be used to jump across &lt;code&gt;obliv if&lt;/code&gt; boundaries. Jump-like statements can only move control flow within the same &lt;code&gt;obliv if&lt;/code&gt; block.&lt;/p&gt;

&lt;h2 id=&#34;functions&#34;&gt;Functions&lt;/h2&gt;

&lt;p&gt;Consider the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int x;
void func() { x++; }
…
void protocolMain() {
  obliv if (...) 
    func(); // Not valid code!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is obviously problematic, since it would violate the restrictions on &lt;code&gt;obliv if&lt;/code&gt;: we are modifying a global, non-obliv variable &lt;code&gt;x&lt;/code&gt; inside an oblivious context.&lt;/p&gt;

&lt;p&gt;To accommodate function calls in oblivious contexts, Obliv-C introduces &lt;code&gt;obliv&lt;/code&gt; functions. We now have two kinds of functions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void func() { … }
void func2() obliv { … }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The difference is simple: you are allowed to perform any operation inside a normal (non-obliv) function (&lt;code&gt;func()&lt;/code&gt;), but it may not be invoked from inside an oblivious context (which includes any &lt;code&gt;obliv if&lt;/code&gt; block, as well as inside other &lt;code&gt;obliv&lt;/code&gt; functions).&lt;/p&gt;

&lt;p&gt;On the other hand, &lt;code&gt;func2&lt;/code&gt; is an &lt;code&gt;obliv&lt;/code&gt; function &amp;mdash; it can be called from anywhere, but may not modify any non-obliv variables not declared inside the function.&lt;/p&gt;

&lt;p&gt;There is one more issue related to calling functions that comes up when passing parameters by reference. Consider this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void ofunc(int* p1, const int* p2) obliv { … }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When this function is invoked, there are restrictions on what &lt;code&gt;p1&lt;/code&gt; can point to. For example, this is problematic:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int n, m;
obliv if (...) { ofunc(&amp;amp;n,&amp;amp;m); } // error
obliv if (...) { int i; ofunc(&amp;amp;i,&amp;amp;m); } // ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When compiling, the compiler sees &lt;code&gt;n&lt;/code&gt; being passed by reference. So it assumes that &lt;code&gt;ofunc&lt;/code&gt; may be used to modify &lt;code&gt;n&lt;/code&gt;. The variable &lt;code&gt;i&lt;/code&gt; is declared inside, so the second invocation is okay, since i can be modified in this scope. Non-obliv variables declared outside becomes something like a &lt;code&gt;const&lt;/code&gt; variable when entering an oblivious scope. We say “something like a const” because there is a slight difference between C’s notion of &lt;code&gt;const&lt;/code&gt;, and our notion here of a &lt;code&gt;frozen&lt;/code&gt; variable.&lt;/p&gt;

&lt;h2 id=&#34;frozen&#34;&gt;&lt;code&gt;frozen&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;For simple variables, &lt;code&gt;frozen&lt;/code&gt; may be implicitly converted to &lt;code&gt;const&lt;/code&gt;: &lt;code&gt;frozen int*&lt;/code&gt; can be used whenever a function really expects &lt;code&gt;const int*&lt;/code&gt;. The difference, however, shows up in case of structs, where they are not implicitly convertible. Here, &lt;code&gt;frozen struct foo*&lt;/code&gt; refers to the “deep-const” version of &lt;code&gt;foo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Consider the following code fragment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct S { int x, *p; };
void func(const struct S* a, frozen struct S* b) {
  // Neither a-&amp;gt;x nor b-&amp;gt;x can be modified here, as expected
  a-&amp;gt;x = 5;  // error
  b-&amp;gt;x = 5;  // error
  // But *b-&amp;gt;p is different from *a-&amp;gt;p
  *a-&amp;gt;p = 5; // ok: a-&amp;gt;p has type int *const,
             //   as opposed to const int*
  *b-&amp;gt;p = 5; // still error; frozen is recursively applied 
             //   to all pointer fields in a struct/union
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This slight difference is the reason Obliv-C introducing the new keyword &lt;code&gt;frozen&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In general, any non-obliv variable becomes frozen-qualified when entering an oblivious scope. For simpler types, this distinction between &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;frozen&lt;/code&gt; does not matter. But for structs, unions, pointer-to-pointers, etc., it does. For example, &lt;code&gt;int **frozen&lt;/code&gt; is actually the same as &lt;code&gt;const int *const *const&lt;/code&gt;, which is different from &lt;code&gt;const int**&lt;/code&gt; or &lt;code&gt;int **const&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;unconditional-segments&#34;&gt;Unconditional Segments&lt;/h2&gt;

&lt;p&gt;This is the one part of Obliv-C that looks very different from anything in C. Essentially, it chalks out a block of code for &lt;em&gt;unconditional&lt;/em&gt; execution even though the surrounding code is conditional on some oblivious data.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int n = …;
obliv if (cond) { // line 1
  n = 5; // error: cannot modify outer non-obliv n in obliv scope
  ~obliv(c) {
    n = 5; // valid: but the assignment happens even if c is false
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the execution of the &lt;code&gt;~obliv&lt;/code&gt; block does not depend on any obliv value, it gets rid of all restrictions on frozen variable modification. The restrictions can be later reinstated by using a nested obliv-if structure, if desired.&lt;/p&gt;

&lt;p&gt;However, remember that we are in an oblivious context, and the contents of the &lt;code&gt;~obliv&lt;/code&gt; block will be executed regardless of the value of the condition. So, &lt;code&gt;n&lt;/code&gt; will be modified inside the &lt;code&gt;~obliv&lt;/code&gt; even if the condition is false!&lt;/p&gt;

&lt;p&gt;The value of the parameter &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;~obliv(c)&lt;/code&gt; will hold the condition. The &lt;code&gt;~obliv(varname)&lt;/code&gt; syntax declares a new variable, &lt;code&gt;varname&lt;/code&gt; of type &lt;code&gt;obliv bool&lt;/code&gt; that indicate whether the enclosing oblivious condition is true or false.&lt;/p&gt;

&lt;p&gt;This syntax is useful for library developers when they know that there is a more efficient way of executing obliv functions than what one can otherwise write. Many of the standard library functions (for example, ORAM designs) use this feature, so you can find useful examples of its use there. In general, when this is used, it is the responsibility of the programmer to make it look like nothing is being executed even when the condition is false (i.e., its execution should not have any visible non-obliv side effects if cond is false, or such side-effects should be constrained to implementation-internal variables only). On the other hand, neither should the programmer assume that it will always be executed even if the condition is false, since the compiler is allowed to optimize it away.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;~obliv&lt;/code&gt; escapes the normal type system for Obliv-C, allowing programmers write code that could make no sense if you are not careful. But, it poses no security risk &amp;mdash; the value of the oblivious condition (and all obliv variables) is not known to the execution and protected by the protocol, so there is no risk of leaking oblivious data by using &lt;code&gt;~obliv&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;api-documentation&#34;&gt;API Documentation&lt;/h1&gt;

&lt;p&gt;Take a look through the &lt;a href=&#34;../tutorial&#34;&gt;tutorial&lt;/a&gt; to get started. In order to start running your
Obliv-C program between two parties, ensure that the following Obliv-C library
functions are called in order:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;int protocolAcceptTcp2P(ProtocolDesc* pd, const char* port)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int protocolConnectTcp2P(ProtocolDesc* pd, const char* server, const char* port)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void setCurrentParty(ProtocolDesc* pd, int party)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void execYaoProtocol(ProtocolDesc* pd, protocol_run start, void* arg)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Any Obliv-C functions needed in your &lt;code&gt;.oc&lt;/code&gt; files&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void cleanupProtocol(ProtocolDesc* pd)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;c-functions&#34;&gt;C Functions&lt;/h2&gt;

&lt;p&gt;These functions should be called in a C file, and require using &lt;code&gt;#include &amp;lt;obliv.h&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;int-protocolaccepttcp2p-protocoldesc-pd-const-char-port&#34;&gt;int protocolAcceptTcp2P(ProtocolDesc* pd, const char* port)&lt;/h3&gt;

&lt;p&gt;The first party calls this function to listen for a second party on
the supplied port parameter. Use conditional logic to ensure only the
first party calls this function.&lt;/p&gt;

&lt;h3 id=&#34;int-protocolconnecttcp2p-protocoldesc-pd-const-char-server-const-char-port&#34;&gt;int protocolConnectTcp2P(ProtocolDesc* pd, const char* server, const char* port)&lt;/h3&gt;

&lt;p&gt;The second party should call this function after the first party calls
&lt;code&gt;protocolAcceptTcp2P()&lt;/code&gt;; use conditional logic to ensure this. Supply
either &amp;lsquo;localhost&amp;rsquo;, the IP address, or the DNS name of the first party
to the &lt;code&gt;const char* server&lt;/code&gt; parameter.&lt;/p&gt;

&lt;h3 id=&#34;void-setcurrentparty-protocoldesc-pd-int-party&#34;&gt;void setCurrentParty(ProtocolDesc* pd, int party)&lt;/h3&gt;

&lt;p&gt;Sets the proper parties into the &lt;code&gt;ProtocolDesc&lt;/code&gt;. Call this before
calling &lt;code&gt;execYaoProtocol()&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;void-execyaoprotocol-protocoldesc-pd-protocol-run-start-void-arg&#34;&gt;void execYaoProtocol(ProtocolDesc* pd, protocol_run start, void* arg)&lt;/h3&gt;

&lt;p&gt;Call this function in your C file&amp;rsquo;s &lt;code&gt;main()&lt;/code&gt; function to execute Yao&amp;rsquo;s
garbled circuits protocol. Supply the starting function name (without
parentheses) in the Obliv-C file as the parameter for &lt;code&gt;protocol_run
start&lt;/code&gt;. Supply any arguments for the Obliv-C starting function in
&lt;code&gt;void* arg&lt;/code&gt;; pass in a struct to supply multiple parameters. Before
calling this function, establish a connection between parties with
&lt;code&gt;protocolAcceptTcp2P()&lt;/code&gt; and &lt;code&gt;protocolConnectTcp2P()&lt;/code&gt;, and call
&lt;code&gt;setCurrentParty()&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;void-cleanupprotocol-protocoldesc-pd&#34;&gt;void cleanupProtocol(ProtocolDesc* pd)&lt;/h3&gt;

&lt;p&gt;Call this function in your C file after &lt;code&gt;execYaoProtocol()&lt;/code&gt; has been
called. This function will clean up the &lt;code&gt;ProtocolDesc&lt;/code&gt; object.&lt;/p&gt;

&lt;h2 id=&#34;obliv-c-functions&#34;&gt;Obliv-C Functions&lt;/h2&gt;

&lt;p&gt;These functions should be used in Obliv-C (&lt;code&gt;.oc&lt;/code&gt;) files. They require `#include &lt;obliv.oh&gt;&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Valid substitutions for &lt;em&gt;&lt;code&gt;tname&lt;/code&gt;&lt;/em&gt; are &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;,
&lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, or &lt;code&gt;float&lt;/code&gt;.  The value of _&lt;code&gt;&amp;lt;Tname&amp;gt;&lt;/code&gt; is the
corresponding type name with its first letter capitalized. (As of
March 2018, the &lt;code&gt;obliv&lt;/code&gt; qualifier is not supported for
double-precision floating point, however, &lt;a href=&#34;https://github.com/samee/obliv-c/pull/30&#34;&gt;single-precision floating
point support is
available&lt;/a&gt;.)&lt;/p&gt;

&lt;h3 id=&#34;obliv-tname-feedobliv-tname-tname-v-int-party&#34;&gt;obliv &lt;em&gt;tname&lt;/em&gt; feedObliv&amp;lt;&lt;em&gt;Tname&lt;/em&gt;&amp;gt;(&lt;em&gt;tname&lt;/em&gt; v, int party)&lt;/h3&gt;

&lt;p&gt;This function returns an &lt;code&gt;obliv&lt;/code&gt;-qualified type from the specified
party to both parties.  For example, for &lt;code&gt;float&lt;/code&gt;, there is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   obliv float feedOblivFloat(float v, int party)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sample code for using this function to feed an int array from the specified
party into an obliv int array to both parties:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void toObliv(int n, obliv int *oa, int *a, int party) {
  int i, res;
  for(i = 0; i &amp;lt; n; i++) {
    oa[i] = feedOblivInt(a[i], party);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;name-ocbroadcast-tname-tname-v-int-source&#34;&gt;name ocBroadcast&amp;lt;&lt;em&gt;Tname&lt;/em&gt;&amp;gt;(&lt;em&gt;tname&lt;/em&gt; v, int source)&lt;/h3&gt;

&lt;p&gt;Returns &lt;em&gt;v&lt;/em&gt; from the specified source (party). This function allows
non-obliv data to be transferred across parties, similar to
&lt;code&gt;feedObliv&amp;lt;Tname&amp;gt;()&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;bool-revealobliv-tname-tname-dest-obliv-tname-src-int-party&#34;&gt;bool revealObliv&amp;lt;&lt;em&gt;Tname&lt;/em&gt;&amp;gt;(&lt;em&gt;tname&lt;/em&gt;* dest, obliv &lt;em&gt;tname&lt;/em&gt; src, int party)&lt;/h3&gt;

&lt;p&gt;Return value true indicated that &lt;code&gt;dest&lt;/code&gt; was written to
successfully. &lt;code&gt;party&lt;/code&gt; indicates which party will receive the revealed
obliv value; use &lt;code&gt;0&lt;/code&gt; for all parties to receive the revealed value. It
is typical for this function to be called towards the end of a
protocol execution, revealing the output of the function that was
computed security to both parties.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>//oblivc.org/projects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//oblivc.org/projects/</guid>
      <description>

&lt;h2 id=&#34;projects-using-obliv-c&#34;&gt;Projects Using Obliv-C&lt;/h2&gt;

&lt;h3 id=&#34;libraries-and-protocols&#34;&gt;Libraries and Protocols&lt;/h3&gt;

&lt;h4 id=&#34;floram-https-gitlab-com-neucrypt-floram&#34;&gt;&lt;a href=&#34;https://gitlab.com/neucrypt/floram&#34;&gt;floram&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Jack Doerner and abhi shelat. &lt;a href=&#34;https://acmccs.github.io/papers/p523-doernerA.pdf&#34;&gt;&lt;em&gt;Scaling ORAM for Secure
Computation&lt;/em&gt;&lt;/a&gt;. In
&lt;a href=&#34;https://ccs2017.sigsac.org/&#34;&gt;&lt;em&gt;24&lt;sup&gt;th&lt;/sup&gt; ACM Conference on Computer and Communications
Security&lt;/em&gt;&lt;/a&gt;. Dallas, TX. 31 Oct-3 November
2017. (Best Paper Award)&lt;/p&gt;

&lt;h4 id=&#34;sqoram-sqoram&#34;&gt;&lt;a href=&#34;//oblivc.org/sqoram&#34;&gt;SqORAM&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Samee Zahur, Xiao Wang, Mariana Raykova, Adrià Gascón, Jack Doerner,
David Evans, Jonathan Katz. &lt;a href=&#34;//oblivc.org/docs/sqoram.pdf&#34;&gt;&lt;em&gt;Revisiting Square-Root ORAM Efficient
Random Access in Multi-Party Computation&lt;/em&gt;&lt;/a&gt; In
&lt;a href=&#34;http://www.ieee-security.org/TC/SP2016/&#34;&gt;&lt;em&gt;37&lt;sup&gt;th&lt;/sup&gt; IEEE Symposium on Security and
Privacy&lt;/em&gt;&lt;/a&gt; (&amp;ldquo;Oakland&amp;rdquo;). San
Jose, CA. 23-25 May 2016.&lt;/p&gt;

&lt;h4 id=&#34;absentminded-crypto-kit-https-bitbucket-org-jackdoerner-absentminded-crypto-kit&#34;&gt;&lt;a href=&#34;https://bitbucket.org/jackdoerner/absentminded-crypto-kit&#34;&gt;Absentminded Crypto Kit&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Jack Doerner.  Library of oblivious implementations of cryptographic
primitives implemented in Obliv-C.  Includes big integer math, hash
functions, sorting, graph algorithms, oblivious data structures, and
ORAM implementations.  [Code:&amp;nbsp;&lt;a href=&#34;https://bitbucket.org/jackdoerner/absentminded-crypto-kit&#34;&gt;https://bitbucket.org/jackdoerner/absentminded-crypto-kit&lt;/a&gt;]&lt;/p&gt;

&lt;h4 id=&#34;half-gates&#34;&gt;Half-Gates&lt;/h4&gt;

&lt;p&gt;Samee Zahur, Mike Rosulek, and David Evans.  &lt;a href=&#34;http://mightbeevil.com/halfgates/&#34;&gt;&lt;em&gt;Two Halves Make a Whole: Reducing Data Transfer in Garbled Circuits using Half Gates&lt;/em&gt;&lt;/a&gt;.  In &lt;a href=&#34;https://www.cosic.esat.kuleuven.be/eurocrypt_2015/papers.shtml&#34;&gt;EuroCrypt 2015&lt;/a&gt;.  Sofia, Bulgaria.  26-30 April 2015. [&lt;a href=&#34;http://www.cs.virginia.edu/evans/pubs/ec2015/halfgates.pdf&#34;&gt;PDF&lt;/a&gt;, 28 pages] [&lt;a href=&#34;http://github.com/samee/obliv-c&#34;&gt;Code&lt;/a&gt;]&lt;/p&gt;

&lt;h3 id=&#34;applications&#34;&gt;Applications&lt;/h3&gt;

&lt;h4 id=&#34;oblivious-knuth-morris-pratt-sub-string-search-https-github-com-jnayak1-kmp-mpc&#34;&gt;&lt;a href=&#34;https://github.com/jnayak1/kmp-mpc&#34;&gt;Oblivious Knuth-Morris-Pratt Sub-String Search&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Jesse Nayak (capstone project). Code: &lt;a href=&#34;https://github.com/jnayak1/kmp-mpc&#34;&gt;&lt;em&gt;https://github.com/jnayak1/kmp-mpc&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;privacy-preserving-distributed-linear-regression-on-high-dimensional-data-https-eprint-iacr-org-2016-892&#34;&gt;&lt;a href=&#34;https://eprint.iacr.org/2016/892&#34;&gt;Privacy-Preserving Distributed Linear Regression on High-Dimensional Data&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Adria&amp;#768; Gasco&amp;#769;n and Phillipp Schoppmann and Borja Balle and
Mariana Raykova and Jack Doerner and Samee Zahur and David Evans. In &lt;a href=&#34;https://petsymposium.org/2017/&#34;&gt;Privacy Enhancing Technologies Symposium&lt;/a&gt; (PETS).  Minneapolis, Minnesota, 18 &amp;ndash; 21 July 2017. [&lt;a href=&#34;//oblivc.org/docs/distributedregression.pdf&#34;&gt;PDF&lt;/a&gt;]&lt;/p&gt;

&lt;h4 id=&#34;decentralized-certificate-authorities-dca&#34;&gt;&lt;a href=&#34;//oblivc.org/dca&#34;&gt;Decentralized Certificate Authorities&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Bargav Jayaraman, Hannah Li, David Evans. &lt;a
href=&#34;/docs/dca.pdf&#34;&gt;&lt;em&gt;Decentralized Certificate
Authorities&lt;/em&gt;&lt;/a&gt;. 11 June 2017. (updated 10 October 2017) (The first two
authors both contributed as co-equal first authors.) [&lt;a href=&#34;//oblivc.org/docs/dca.pdf&#34;&gt;PDF&lt;/a&gt;]&lt;/p&gt;

&lt;h4 id=&#34;privacy-preserving-machine-learning-ppml&#34;&gt;&lt;a href=&#34;//oblivc.org/ppml&#34;&gt;Privacy-Preserving Machine Learning&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Lu Tian, Bargav Jayaraman, Quanquan Gu, and David Evans. &lt;a href=&#34;//oblivc.org/docs/pmpml.pdf&#34;&gt;&lt;em&gt;Aggregating
Private Sparse Learning Models Using Multi-Party
Computation&lt;/em&gt;&lt;/a&gt;. In &lt;a href=&#34;https://pmpml.github.io/PMPML16/&#34;&gt;Private Multi‑Party Machine
Learning&lt;/a&gt; (NIPS 2016 Workshop),
Barcelona, 9 December 2016. [&lt;a href=&#34;//oblivc.org/docs/pmpml.pdf&#34;&gt;PDF&lt;/a&gt;]&lt;/p&gt;

&lt;h4 id=&#34;secure-stable-matching-matching&#34;&gt;&lt;a href=&#34;//oblivc.org/matching&#34;&gt;Secure Stable Matching&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Jack Doerner, David Evans, abhi shelat. &lt;a href=&#34;http://oblivc.org/docs/matching.pdf&#34;&gt;&lt;em&gt;Secure Stable Matching at Scale&lt;/em&gt;&lt;/a&gt;.  In &lt;a href=&#34;https://www.sigsac.org/ccs/CCS2016/&#34;&gt;&lt;em&gt;23&lt;sup&gt;rd&lt;/sup&gt; ACM Conference on Computer and Communications Security&lt;/em&gt;&lt;/a&gt; (CCS). Vienna, Austria. 24-28 October 2016. [&lt;a href=&#34;//oblivc.org/docs/matching.pdf&#34;&gt;PDF&lt;/a&gt;]&lt;/p&gt;

&lt;h4 id=&#34;secure-deep-learning&#34;&gt;Secure Deep Learning&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/bargavjayaraman/SecureDeepLearning&#34;&gt;https://github.com/bargavjayaraman/SecureDeepLearning&lt;/a&gt;&lt;br /&gt;
Bargav Jayaraman (Accenture Technology Labs, Bangalore &amp;rarr; now at UVA)&lt;/p&gt;

&lt;h3 id=&#34;applications-built-with-obliv-c-by-others&#34;&gt;Applications Built with Obliv-C by Others&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/1806.03281&#34;&gt;Blind Justice: Fairness with Encrypted Sensitive Attributes&lt;/a&gt;.
Niki Kilbertus, Adri&amp;agrave;  Gasc&amp;oacute;n, Matt J. Kusner, Michael Veale, Krishna P. Gummadi, Adrian Weller. ICML 2018. &lt;a href=&#34;https://arxiv.org/pdf/1806.03281.pdf&#34;&gt;PDF&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://eprint.iacr.org/2018/289.pdf&#34;&gt;Private Nearest Neighbors Classification in Federated Databases&lt;/a&gt;, Phillipp Schoppmann, Adri&amp;agrave;  Gasc&amp;oacute;n, and Borja Balle.&lt;br /&gt;
&lt;a href=&#34;https://eprint.iacr.org/2018/289&#34;&gt;Cryptology ePrint Archive: Report 2018 / 289&lt;/a&gt;. March 2018.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cs.nyu.edu/~mwalfish/papers/pretzel-sigcomm17.pdf&#34;&gt;Pretzel: Email encryption and provider-supplied functions are
compatible&lt;/a&gt;,
Trinabh Gupta, Henrique Fingler, Lorenzo Alvisi, and Michael
Walfish. ACM SIGCOMM 2017.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://calctopia.com&#34;&gt;SECCOMP - The Secure Spreadsheet&lt;/a&gt;, Calctopia, 2017.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Decentralized Certificate Authorities</title>
      <link>//oblivc.org/dca/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//oblivc.org/dca/</guid>
      <description>

&lt;p&gt;The security of TLS depends on trust in certificate authorities, and
that trust stems from their ability to protect and control the use of
a private signing key.  The signing key is the key asset of a
certificate authority (CA), and its value is based on trust in the
corresponding public key which is primarily distributed by browser
vendors.  Compromise of a CA private key represents a single
point-of-failure that could have disastrous consequences, so CAs go to
great lengths to attempt to protect and control the use of their
private keys. Nevertheless, keys are sometimes compromised and may be
misused accidentally or intentionally by insiders.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;//oblivc.org/images/dca.png&#34;&gt;&lt;img src=&#34;//oblivc.org/images/dca-small.png&#34; width=750 height=500&gt;&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;We propose a new model where a CA&amp;rsquo;s private key is split among
multiple parties, and signatures are produced using a secure
multi-party computation protocol that never exposes the actual signing
key. This could be used by a single CA to reduce the risk that its
signing key would be compromised or misused. It could also enable new
models for certificate generation, where multiple CAs would need to
agree and cooperate before a new certificate can be generated, or even
where certificate generation would require cooperation between a CA
and the certificate recipient (subject). We demonstrate the
practicality of this concept with an evaluation of a prototype
implementation that uses secure two-party computation to generate
certificates signed using ECDSA on curve secp192k1. We show that using
Amazon AWS EC2 c4.2xlarge nodes to jointly sign a certificate costs as
little as 28.2-32.6 cents without bandwidth cost and approximately
8.54 dollars with bandwidth cost.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;paper&#34;&gt;Paper&lt;/h2&gt;

&lt;p&gt;Bargav Jayaraman&lt;sup&gt;&amp;dagger;&lt;/sup&gt;, Hannah Li&lt;sup&gt;&amp;dagger;&lt;/sup&gt;, David Evans. &lt;a
href=&#34;/docs/dca.pdf&#34;&gt;&lt;em&gt;Decentralized Certificate
Authorities&lt;/em&gt;&lt;/a&gt;. &lt;a href=&#34;https://arxiv.org/abs/1706.03370&#34;&gt;arXiv:1706.03370&lt;/a&gt;. 11 June 2017 (updated 10 October 2017). (&lt;a href=&#34;https://arxiv.org/pdf/1706.03370.pdf&#34;&gt;PDF&lt;/a&gt;, 12 pages)&lt;br /&gt;
(&amp;dagger; The first two authors contributed as co-equal first authors.)&lt;/p&gt;

&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hainali/decentralizedca&#34;&gt;&lt;em&gt;&lt;a href=&#34;https://github.com/hainali/decentralizedca&#34;&gt;https://github.com/hainali/decentralizedca&lt;/a&gt;&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;people&#34;&gt;People&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://bargavjayaraman.github.io/&#34;&gt;Bargav Jayaraman&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/HainaLi&#34;&gt;Hannah Li&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.cs.virginia.edu/evans&#34;&gt;David Evans&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Obliv-C Publications</title>
      <link>//oblivc.org/pubs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//oblivc.org/pubs/</guid>
      <description>

&lt;p&gt;Bargav Jayaraman and David Evans. [&lt;em&gt;Evaluating Differentially Private Machine
Learning in Practice&lt;/em&gt;]. &lt;a
href=&#34;https://www.usenix.org/conference/usenixsecurity19&#34;&gt;28&lt;sup&gt;th&lt;/sup&gt;
USENIX Security Symposium&lt;/em&gt;&lt;/a&gt;. Santa&amp;nbsp;Clara. August 2019.
[&lt;a href=&#34;usenix2019/evaluatingdp.pdf&#34;&gt;PDF&lt;/a&gt;, 20 pages]
[&lt;a href=&#34;https://arxiv.org/abs/1902.08874&#34;&gt;arXiv&lt;/a&gt;]
[&lt;A href=&#34;https://github.com/bargavj/EvaluatingDPML&#34;&gt;code&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Bargav Jayaraman, Lingxiao Wang, David Evans and Quanquan Gu. &lt;a href=&#34;//www.cs.virginia.edu/evans/pubs/neurips2018/neurips2018.pdf&#34;&gt;&lt;em&gt;Distributed Learning without Distress:
Privacy-Preserving Empirical Risk Minimization&lt;/em&gt;&lt;/a&gt;. &lt;a href=&#34;https://nips.cc/Conferences/2018/&#34;&gt;32&lt;sup&gt;nd&lt;/sup&gt; Conference on Neural Information Processing Systems&lt;/a&gt; (NeurIPS). Montreal, Canada. December 2018. [&lt;a href=&#34;//www.cs.virginia.edu/evans/pubs/neurips2018/neurips2018.pdf&#34;&gt;PDF&lt;/a&gt;, 19 pages, including supplemental materials]&lt;/p&gt;

&lt;p&gt;Jack Doerner and abhi shelat. &lt;a href=&#34;https://acmccs.github.io/papers/p523-doernerA.pdf&#34;&gt;&lt;em&gt;Scaling ORAM for Secure
Computation&lt;/em&gt;&lt;/a&gt;. In
&lt;a href=&#34;https://ccs2017.sigsac.org/&#34;&gt;&lt;em&gt;24&lt;sup&gt;th&lt;/sup&gt; ACM Conference on Computer and Communications
Security&lt;/em&gt;&lt;/a&gt;. Dallas, TX. 31 Oct-3 November
2017. (Best Paper Award)&lt;/p&gt;

&lt;p&gt;Adria&amp;#768; Gasco&amp;#769;n and Phillipp Schoppmann and Borja Balle and
Mariana Raykova and Jack Doerner and Samee Zahur and David Evans.
&lt;a href=&#34;//oblivc.org/docs/distributedregression.pdf&#34;&gt;&lt;em&gt;Privacy-Preserving Distributed Linear Regression on High-Dimensional Data&lt;/em&gt;&lt;/a&gt;. In &lt;a href=&#34;https://petsymposium.org/2017/&#34;&gt;Privacy Enhancing Technologies Symposium&lt;/a&gt; (PETS).  Minneapolis, Minnesota, 18 &amp;ndash; 21 July 2017. [&lt;a href=&#34;//oblivc.org/docs/distributedregression.pdf&#34;&gt;PDF&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Bargav Jayaraman, Hannah Li, David Evans. &lt;a
href=&#34;/docs/dca.pdf&#34;&gt;&lt;em&gt;Decentralized Certificate
Authorities&lt;/em&gt;&lt;/a&gt;. 11 June 2017. (updated 10 October 2017) (The first two
authors both contributed as co-equal first authors.) [&lt;a href=&#34;//oblivc.org/docs/dca.pdf&#34;&gt;PDF&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Jack Doerner, David Evans, abhi shelat. &lt;a href=&#34;http://oblivc.org/docs/matching.pdf&#34;&gt;&lt;em&gt;Secure Stable Matching at Scale&lt;/em&gt;&lt;/a&gt;.  In &lt;a href=&#34;https://www.sigsac.org/ccs/CCS2016/&#34;&gt;&lt;em&gt;23&lt;sup&gt;rd&lt;/sup&gt; ACM Conference on Computer and Communications Security&lt;/em&gt;&lt;/a&gt; (CCS). Vienna, Austria. 24-28 October 2016. [&lt;a href=&#34;//oblivc.org/docs/matching.pdf&#34;&gt;PDF&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Samee Zahur, Xiao Wang, Mariana Raykova, Adrià Gascón, Jack Doerner,
David Evans, Jonathan Katz. &lt;a href=&#34;//oblivc.org/docs/sqoram.pdf&#34;&gt;&lt;em&gt;Revisiting Square-Root ORAM Efficient
Random Access in Multi-Party Computation&lt;/em&gt;&lt;/a&gt; In
&lt;a href=&#34;http://www.ieee-security.org/TC/SP2016/&#34;&gt;&lt;em&gt;37&lt;sup&gt;th&lt;/sup&gt; IEEE Symposium on Security and
Privacy&lt;/em&gt;&lt;/a&gt; (&amp;ldquo;Oakland&amp;rdquo;). San
Jose, CA. 23-25 May 2016. [&lt;a href=&#34;//oblivc.org/docs/squoram.pdf&#34;&gt;PDF&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Samee Zahur, Mike Rosulek, and David Evans.  &lt;a href=&#34;http://mightbeevil.com/halfgates/&#34;&gt;&lt;em&gt;Two Halves Make a Whole: Reducing Data Transfer in Garbled Circuits using Half Gates&lt;/em&gt;&lt;/a&gt;.  In &lt;a href=&#34;https://www.cosic.esat.kuleuven.be/eurocrypt_2015/papers.shtml&#34;&gt;EuroCrypt 2015&lt;/a&gt;.  Sofia, Bulgaria.  26-30 April 2015. [&lt;a href=&#34;http://www.cs.virginia.edu/evans/pubs/ec2015/halfgates.pdf&#34;&gt;PDF&lt;/a&gt;, 28 pages] [&lt;a href=&#34;http://github.com/samee/obliv-c&#34;&gt;Code&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Samee Zahur and David Evans. &lt;a href=&#34;http://eprint.iacr.org/2015/1153.pdf&#34;&gt;&lt;em&gt;Obliv-C: A Language for Extensible
Data-Oblivious Computation&lt;/em&gt;&lt;/a&gt;,
&lt;a href=&#34;http://eprint.iacr.org/2015/1153&#34;&gt;Cryptology ePrint Archive: Report
2015:1153&lt;/a&gt;
[&lt;a href=&#34;http://eprint.iacr.org/2015/1153&#34;&gt;PDF&lt;/a&gt;], November 2015.&lt;/p&gt;

&lt;p&gt;Samee Zahur and David Evans. &lt;a href=&#34;http://www.ieee-security.org/TC/SP2015/posters/paper_62.pdf&#34;&gt;&lt;em&gt;Poster: Obliv-C: a Fast, Lightweight
Language for Garbled
Circuits&lt;/em&gt;&lt;/a&gt;.
&lt;a href=&#34;www.ieee-security.org/TC/SP2015/&#34;&gt;&lt;em&gt;36&lt;sup&gt;th&lt;/sup&gt; IEEE Symposium on Security and
Privacy&lt;/em&gt;&lt;/a&gt; (&amp;ldquo;Oakland&amp;rdquo;). 18-20 May 2015
(Poster).&lt;/p&gt;

&lt;h3 id=&#34;publications-by-others-using-obliv-c&#34;&gt;Publications by Others using Obliv-C&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/1806.03281&#34;&gt;Blind Justice: Fairness with Encrypted Sensitive Attributes&lt;/a&gt;.
Niki Kilbertus, Adri&amp;agrave;  Gasc&amp;oacute;n, Matt J. Kusner, Michael Veale, Krishna P. Gummadi, Adrian Weller. ICML 2018. &lt;a href=&#34;https://arxiv.org/pdf/1806.03281.pdf&#34;&gt;PDF&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://eprint.iacr.org/2018/289.pdf&#34;&gt;Private Nearest Neighbors Classification in Federated Databases&lt;/a&gt;, Phillipp Schoppmann, Adri&amp;agrave;  Gasc&amp;oacute;n, and Borja Balle.&lt;br /&gt;
&lt;a href=&#34;https://eprint.iacr.org/2018/289&#34;&gt;Cryptology ePrint Archive: Report 2018 / 289&lt;/a&gt;. March 2018.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cs.nyu.edu/~mwalfish/papers/pretzel-sigcomm17.pdf&#34;&gt;Pretzel: Email encryption and provider-supplied functions are
compatible&lt;/a&gt;,
Trinabh Gupta, Henrique Fingler, Lorenzo Alvisi, and Michael
Walfish. ACM SIGCOMM 2017.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Obliv-C Talks</title>
      <link>//oblivc.org/talks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//oblivc.org/talks/</guid>
      <description>&lt;p&gt;David Evans. &lt;a href=&#34;https://www.jeffersonswheel.org/2017/secure-multi-party-computation-promises-protocols-and-practicalities&#34;&gt;&lt;em&gt;Secure Multi-Party Computation: Promises, Protocols, and Practicalities&lt;/em&gt;&lt;/a&gt;. &lt;a href=&#34;http://crypto-events.di.ens.fr/ecryptnet/&#34;&gt;ECRYPT NET Workshop
on Crypto for the Cloud &amp;amp; Implementation&lt;/a&gt;, Paris, France, 27 June
2017. [&lt;a
href=&#34;https://speakerdeck.com/evansuva/secure-multi-party-computation-promises-protocols-and-practicalities&#34;&gt;Speaker&amp;nbsp;Deck&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;David Evans and Denis Nekipelov. &lt;a href=&#34;https://www.jeffersonswheel.org/2016/ftc-visit&#34;&gt;&lt;em&gt;Private Data Analysis using Multi-Party Computation&lt;/em&gt;&lt;/a&gt;.
Federal Trade Commission (joint presentation), 18 August 2016.&lt;/p&gt;

&lt;p&gt;David Evans. &lt;a href=&#34;https://www.jeffersonswheel.org/2016/shanghaitech-symposium&#34;&gt;&lt;em&gt;Memory for Data Oblivious Computation&lt;/em&gt;&lt;/a&gt;.  &lt;a href=&#34;http://ssist2016.shanghaitech.edu.cn/index.html&#34;&gt;ShanghaiTech Symposium&lt;/a&gt;, 25 June
  2016. [&lt;a href=&#34;https://speakerdeck.com/evansuva/memory-for-data-oblivious-computation&#34;&gt;Speaker Deck&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;David Evans. &lt;a href=&#34;https://www.jeffersonswheel.org/2016/aarhus-workshop-on-theory-and-practice-of-secure-multiparty-computation&#34;&gt;&lt;em&gt;From Mercury Delay Lines to Magnetic Core Memories: Progress in Oblivious Memories&lt;/em&gt;&lt;/a&gt;.
&lt;a href=&#34;http://ctic.au.dk/events/workshops-conferences/mpc-2016/&#34;&gt;Workshop
  on Theory and Practice of Secure Multiparty Computation&lt;/a&gt;, Aarhus
  University, Denmark. 1 June 2016. [&lt;a href=&#34;https://speakerdeck.com/evansuva/from-mercury-delay-lines-to-magnetic-core-memories-progress-in-oblivious-memories&#34;&gt;Speaker Deck&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;Samee Zahur. &lt;a href=&#34;http://www.humangenomeprivacy.org/2015/slides/UV.pdf&#34;&gt;&lt;em&gt;Obliv-C: A Simple C Extension for
SMC&lt;/em&gt;&lt;/a&gt;, iDash
Privacy &amp;amp; Security Workshop 2015.  (Won award for fasted &amp;ldquo;Hamming
Distance&amp;rdquo; execution.)&lt;/p&gt;

&lt;p&gt;David Evans. &lt;a href=&#34;http://www.cs.virginia.edu/~evans/talks/crossing2015/&#34;&gt;&lt;em&gt;Multi-Party Computation for the
Masses&lt;/em&gt;&lt;/a&gt;
(includes video).  &lt;a href=&#34;https://www.crossing.tu-darmstadt.de/en/news-events/crossing-conference-2015/&#34;&gt;CROSSING Conference 2015: Where Quantum Physics,
Cryptography, System Security and Software Engineering
Meet&lt;/a&gt;. Darmstadt. 1 June 2015&lt;/p&gt;

&lt;p&gt;Samee Zahur. &lt;a href=&#34;http://research.microsoft.com/apps/video/dl.aspx?id=20989&#34;&gt;&lt;em&gt;Obliv-C: A Lightweight Compiler for Data-Oblivious
Computation&lt;/em&gt;&lt;/a&gt;
(includes video). Applied Multi-Party Computation.  Microsoft Research,
Redmond, WA. 20 February 2014.
   &lt;/div&gt;
   &lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Obliv-C Tutorial</title>
      <link>//oblivc.org/tutorial/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//oblivc.org/tutorial/</guid>
      <description>

&lt;p&gt;Obliv-C is a simple GCC wrapper that makes it easy to embed secure
computation protocols inside regular C programs. This tutorial
explains how to set up and build your first Obliv-C program using
privacy-preserving linear regression application as an example.&lt;/p&gt;

&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;

&lt;h4 id=&#34;1-install-dependencies&#34;&gt;1. Install Dependencies&lt;/h4&gt;

&lt;p&gt;Before setting up Obliv-C, several other modules need to be installed. Here are the commands to do the installations, depending on your platform.&lt;/p&gt;

&lt;p&gt;Ubuntu:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;$ sudo apt install ocaml libgcrypt20-dev ocaml-findlib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fedora:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;$ sudo dnf install glibc-devel.i686 ocaml ocaml-ocamldoc ocaml-findlib ocaml-findlib-devel libgcrypt libgcrypt-devel perl-ExtUtils-MakeMaker perl-Data-Dumper
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mac OS (with Macports):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;$ sudo port install gcc5 ocaml ocaml-findlib libgcrypt +devel
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-cloning-obliv-c&#34;&gt;2. Cloning Obliv-C&lt;/h4&gt;

&lt;p&gt;Clone the &lt;a href=&#34;https://github.com/samee/obliv-c&#34;&gt;Obliv-C source repository&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ git clone https://github.com/samee/obliv-c
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-build-obliv-c&#34;&gt;3. Build Obliv-C&lt;/h4&gt;

&lt;p&gt;Linux:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;$ ./configure &amp;amp;&amp;amp; make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mac OS:&lt;/p&gt;

&lt;p&gt;First, you need to install &lt;a href=&#34;https://guide.macports.org/chunked/installing.macports.html&#34;&gt;MacPorts&lt;/a&gt;.  Then,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;$ CC=/opt/local/bin/gcc-mp-5 CPP=/opt/local/bin/cpp-mp-5 LIBRARY_PATH=/opt/local/lib ./configure &amp;amp;&amp;amp; make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;re all set!&lt;/p&gt;

&lt;p&gt;The compiler is a GCC wrapper script found in &lt;code&gt;bin/oblivcc&lt;/code&gt;.  Example programs are in &lt;code&gt;test/oblivc&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;understanding-obliv-c-programs&#34;&gt;Understanding Obliv-C Programs&lt;/h2&gt;

&lt;p&gt;Here, we explain how an Obliv-C program works in four steps. For this tutorial, we implement a sample linear regression in Obliv-C: &lt;a href=&#34;https://github.com/samee/obliv-c/tree/obliv-c/test/oblivc/linreg&#34;&gt;https://github.com/samee/obliv-c/tree/obliv-c/test/oblivc/linreg&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This example is for instructional purposes only, and does not take
advantage of all features of Obliv-C and favors simplicity over
performance.&lt;/p&gt;

&lt;h3 id=&#34;1-connecting-parties-storing-arguments-and-executing-yao-s-protocol&#34;&gt;1. Connecting parties, storing arguments, and executing Yao&amp;rsquo;s protocol&lt;/h3&gt;

&lt;p&gt;The protocol is started in &lt;code&gt;main()&lt;/code&gt; in
&lt;a href=&#34;https://github.com/samee/obliv-c/blob/obliv-c/test/oblivc/linreg/linreg.c&#34;&gt;linreg.c&lt;/a&gt;. The
&lt;code&gt;#include &amp;lt;obliv.h&amp;gt;&lt;/code&gt; header is needed to incorporate the Obliv-C library.&lt;/p&gt;

&lt;p&gt;The first step to creating a protocol is to initialize a
&lt;code&gt;ProtocolDesc&lt;/code&gt; object, stored in the &lt;code&gt;pd&lt;/code&gt; variable in this code. This
is needed as an argument for several essential functions.&lt;/p&gt;

&lt;p&gt;After storing the command-line arguments (hostname, TCP port, party,
and data filename) to &lt;code&gt;protocolIO io&lt;/code&gt; (a struct defined in
&lt;a href=&#34;https://github.com/samee/obliv-c/blob/obliv-c/test/oblivc/linreg/linreg.h&#34;&gt;linreg.h&lt;/a&gt;),
a connection must be established between the two parties.  The
&lt;code&gt;ProtocolDesc&lt;/code&gt; structure is a convenient way to represent
data used in both your C and Obliv-C files.&lt;/p&gt;

&lt;h4 id=&#34;connecting-parties&#34;&gt;Connecting Parties&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// code ...
const char *remote_host = strtok(argv[1], &amp;quot;:&amp;quot;); // parse hostname from cmdline
const char *port = strtok(NULL, &amp;quot;:&amp;quot;); // parse port name from cmdline
ProtocolDesc pd;
protocolIO io;
// code ...
log_info(&amp;quot;Connecting to %s on port %s ...\n&amp;quot;, remote_host, port);
if(argv[2][0] == &#39;1&#39;) {
   if(protocolAcceptTcp2P(&amp;amp;pd,port)!=0) {
      log_err(&amp;quot;TCP accept from %s failed\n&amp;quot;, remote_host);
      exit(1);
   }
} else {
   if(protocolConnectTcp2P(&amp;amp;pd,remote_host,port)!=0) {
      log_err(&amp;quot;TCP connect to %s failed\n&amp;quot;, remote_host);
      exit(1);
   }
}
// code ...
cp = (argv[2][0]==&#39;1&#39;? 1 : 2);
setCurrentParty(&amp;amp;pd, cp); // only checks for a &#39;1&#39;
io.src = argv[3]; // filename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first party calls &lt;code&gt;protocolAcceptTcp2P()&lt;/code&gt; to listen for a connection. The
&lt;code&gt;log_err()&lt;/code&gt; function is defined for this example in &lt;a href=&#34;https://github.com/samee/obliv-c/blob/obliv-c/test/oblivc/linreg/dbg.h&#34;&gt;dbg.h&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The important takeaway from the above code snippet is that the accept
and connect functions were called by the appropriate parties). Then,
the second party calls &lt;code&gt;protocolConnectTcp2P()&lt;/code&gt;, supplying the
hostname from the commandline argument and connecting to the first
party. After a connection is made, &lt;code&gt;setCurrentParty()&lt;/code&gt; is called,
which allows the &lt;code&gt;ProtocolDesc pd&lt;/code&gt; to keep track of parties.&lt;/p&gt;

&lt;h4 id=&#34;executing-yao-s-protocol&#34;&gt;Executing Yao&amp;rsquo;s Protocol&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Execute Yao protocol and cleanup
execYaoProtocol(&amp;amp;pd, linReg, &amp;amp;io);
cleanupProtocol(&amp;amp;pd);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, &lt;code&gt;execYaoProtocol()&lt;/code&gt; is called; this function begins linReg.oc&amp;rsquo;s code at the supplied function name: linReg().&lt;/p&gt;

&lt;h3 id=&#34;2-loading-local-data-and-sharing-obliv-qualified-data&#34;&gt;2. Loading local data and sharing obliv qualified data&lt;/h3&gt;

&lt;p&gt;Now, we switch to the Olbiv-C code in &lt;a href=&#34;https://github.com/samee/obliv-c/blob/obliv-c/test/oblivc/linreg/linreg.oc&#34;&gt;&lt;code&gt;linreg.oc&lt;/code&gt;&lt;/a&gt;. Code in the &lt;code&gt;.oc&lt;/code&gt; files can use the &lt;code&gt;obliv&lt;/code&gt; extensions, and it source-to-source translacted to C code as part of the Obliv-C compilation process.&lt;/p&gt;

&lt;p&gt;Loading local data and obtaining &lt;code&gt;protocolIO&lt;/code&gt; struct values in Obliv-C
is done inside the &lt;code&gt;void linReg()&lt;/code&gt; function, called by
&lt;code&gt;execYaoProtocol()&lt;/code&gt; at the end of step 1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;protocolIO *io = (protocolIO*) args;

int *x = malloc(sizeof(int) * ALLOC);
int *y = malloc(sizeof(int) * ALLOC);
// code ...
load_data(io, &amp;amp;x, &amp;amp;y, ocCurrentParty());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the struct used for accessing variables across C and Obliv-C files (&lt;code&gt;protocolIO io&lt;/code&gt;)
 is obtained from the call to &lt;code&gt;linReg()&lt;/code&gt; by &lt;code&gt;execYaoProtocol()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To load the data points (the private input) from local files for each
party, two int arrays were created with &lt;code&gt;ALLOC&lt;/code&gt; being an initial size
defined in
&lt;a href=&#34;https://github.com/samee/obliv-c/blob/obliv-c/test/oblivc/linreg/linreg.h&#34;&gt;&lt;code&gt;linreg.h&lt;/code&gt;&lt;/a&gt;.
The &lt;code&gt;load_data()&lt;/code&gt; function from
&lt;a href=&#34;https://github.com/samee/obliv-c/blob/obliv-c/test/oblivc/linreg/linreg.c&#34;&gt;&lt;code&gt;linreg.c&lt;/code&gt;&lt;/a&gt;
is called, with the int arrays created in the Obliv-C file being
passed in as parameters.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note that calls can be
made to C file functions even while being in Yao&amp;rsquo;s protocol and
running code in an Obliv-C file&lt;/em&gt;.  The majority of the &lt;code&gt;load_data()&lt;/code&gt;
function is comprised of regular C procedures, with the exception of
this code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;float a_float = (float) a;
if (party == 1) {
   *(*x + io-&amp;gt;n - 1) =  a_float; // messy, but needed for dereferencing 
} else if (party == 2) {
   *(*y + io-&amp;gt;n - 1) =  a_float;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sharing-obliv-data&#34;&gt;Sharing &lt;code&gt;obliv&lt;/code&gt; data&lt;/h4&gt;

&lt;p&gt;Now that the data for each party is stored locally in float arrays,
the data must be made oblivious (converted to &lt;code&gt;obliv&lt;/code&gt;-typed data) and
then shared with the other party as private data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// code ...
check_input_count(io);

obliv float *ox = malloc(sizeof(obliv float) * io-&amp;gt;n);
obliv float *oy = malloc(sizeof(obliv float) * io-&amp;gt;n);
    
toObliv(io, ox, x, 1);
toObliv(io, oy, y, 2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Two new float arrays that are &lt;code&gt;obliv&lt;/code&gt; qualified are created, with size
&lt;code&gt;io-&amp;gt;n&lt;/code&gt; after loading the local data (note that the call to
&lt;code&gt;check_input_count()&lt;/code&gt; ensures both parties sent the same amount of
data using the &lt;code&gt;ocBroadcastFloat()&lt;/code&gt; function). Then, &lt;code&gt;toObliv()&lt;/code&gt; is
called:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// code ...
void toObliv(protocolIO *io, obliv float *oa, float *a, int party) 
{
    for(int i = 0; i &amp;lt; io-&amp;gt;n; i++) {
        oa[i] = feedOblivFloat(a[i], party);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The call to &lt;code&gt;feedOblivFloat()&lt;/code&gt; (see &lt;a href=&#34;../documentation&#34;&gt;documentation&lt;/a&gt;)
allows both parties to share their data over their network connection
as &lt;code&gt;obliv&lt;/code&gt; qualified values.&lt;/p&gt;

&lt;p&gt;The loop in &lt;code&gt;toObliv()&lt;/code&gt; goes through each value in each party&amp;rsquo;s
respective array.  You may notice that while both parties call
&lt;code&gt;toObliv()&lt;/code&gt; twice, the party from which the local float array is
selected is hardcoded into the function call, so as to prevent party 1
from trying to convert its own y array data (which are all 0 because
nothing was ever stored to them) into &lt;code&gt;obliv&lt;/code&gt; values, and vice versa.&lt;/p&gt;

&lt;h3 id=&#34;3-computing-linear-regression&#34;&gt;3. Computing linear regression&lt;/h3&gt;

&lt;h4 id=&#34;computing-the-function-of-two-parties-linear-regression&#34;&gt;Computing the function of two parties (linear regression)&lt;/h4&gt;

&lt;p&gt;Our data has been shared obliviously into two arrays, and we are now
ready to perform our joint function on our private data (linear
regression). The code is very similar to what would be done in a
non-private implementation using standard C, except for the use of
&lt;code&gt;obliv&lt;/code&gt; type qualifiers for the oblivious data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// code ...
int n = io-&amp;gt;n;
obliv float sumx = sum(ox, n); // sum of x
obliv float sumxx = dotProd(ox, ox, n); // sum of each x squared
obliv float sumy = sum(oy, n); // sum of y
obliv float sumyy = dotProd(oy, oy, n); // sum of each y squared
obliv float sumxy = dotProd(ox, oy, n); // sum of each x * y

// Compute least-squares best fit straight line
om = (n * sumxy - (sumx * sumy)) / (n * sumxx - osqr(sumx)); // slope
ob = ((sumy * sumxx) - (sumx * sumxy)) / (n * sumxx - osqr(sumx)); // y-intercept

obliv float ocov = (n * sumxy) - (sumx * sumy);
obliv float ostddevs = ((n * sumxx) - osqr(sumx)) * ((n * sumyy) - osqr(sumy));
obliv float orsqr = osqr(ocov) * ostddevs; // sqrt(revealed rsqr) = r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;sum()&lt;/code&gt; and &lt;code&gt;dotProd()&lt;/code&gt; function allow us to obtain summations
that we need in order to compute our three (oblivious) results: &lt;code&gt;om&lt;/code&gt; (slope),
&lt;code&gt;ob&lt;/code&gt; (obliv y-intercept), and &lt;code&gt;orsqr&lt;/code&gt; (correlation squared).&lt;/p&gt;

&lt;p&gt;We then use these summations to calculate our results, which will be
revealed at the end of the protocol execution.&lt;/p&gt;

&lt;h3 id=&#34;4-revealing-results-cleaning-up&#34;&gt;4. Revealing results, cleaning up&lt;/h3&gt;

&lt;h4 id=&#34;revealing-results&#34;&gt;Revealing Results&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;revealOblivFloat&lt;/code&gt; function is used to reveal the oblivious
results to both parties. The first parameter is the location where the
non-obliv result value is to be stored, a field in the &lt;code&gt;protocolIO io&lt;/code&gt; struct. The second parameter is the &lt;code&gt;obliv&lt;/code&gt; result that will be revealed and stored into that location. Lastly, &amp;lsquo;0&amp;rsquo; specifies that all parties
will receive the result (alternatively a non-zero value could be used to reveal the result to just one of the paries).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;revealOblivFloat(&amp;amp;io-&amp;gt;rsqr, orsqr, 0);
revealOblivFloat(&amp;amp;io-&amp;gt;m, om, 0);
revealOblivFloat(&amp;amp;io-&amp;gt;b, ob, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;cleaning-up-recording-runtime-information&#34;&gt;Cleaning up, recording runtime information&lt;/h4&gt;

&lt;p&gt;Having stored the results as non-obliv floats in the &lt;code&gt;io&lt;/code&gt; struct, we are now ready
to complete Yao&amp;rsquo;s protocol and print our results to the Terminal.&lt;/p&gt;

&lt;p&gt;After freeing our &lt;code&gt;float&lt;/code&gt; arrays and &lt;code&gt;obliv float&lt;/code&gt; arrays, &lt;code&gt;linReg()&lt;/code&gt; finishes,
and as a result &lt;code&gt;execYaoProtocol()&lt;/code&gt;, from
&lt;a href=&#34;https://github.com/samee/obliv-c/blob/obliv-c/test/oblivc/linreg/linreg.c&#34;&gt;linreg.c&lt;/a&gt;,
completes execution as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Execute Yao&#39;s protocol and cleanup
execYaoProtocol(&amp;amp;pd, linReg, &amp;amp;io);
cleanupProtocol(&amp;amp;pd);
// code ...

log_info(&amp;quot;Slope   \tm = %15.6e\n&amp;quot;, io.m); // print slope
log_info(&amp;quot;y-intercept\tb = %15.6e\n&amp;quot;, io.b); // print y-intercept
log_info(&amp;quot;Correlation\tr = %15.6e\n&amp;quot;, sqrt(io.rsqr)); // print correlation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To conclude, &lt;code&gt;cleanupProtocol()&lt;/code&gt;, serving a similar purpose to use of &lt;code&gt;free()&lt;/code&gt;
after calling &lt;code&gt;malloc()&lt;/code&gt; on a given variable.
(Another useful built in function
to Obliv-C is &lt;code&gt;yaoGateCount()&lt;/code&gt;, which gives the number gates executed in the protocol). Finally, we print our results from the linear regression.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We hope that this tutorial of how to implement linear regression
 in Obliv-C will be a useful guide for starting to write
your own Obliv-C programs!  You&amp;rsquo;ll find many more example Obliv-C programs in the repository as well as the other repositories linked for other &lt;a href=&#34;//oblivc.org/#projects&#34;&gt;Obliv-C Projects&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Please let us know if you have any suggestions for improving Obliv-C
or this tutorial.  We also welcome issues and pull requests to the
&lt;a href=&#34;https://github.com/samee/obliv-c&#34;&gt;Obliv-C repository&lt;/a&gt; and deeply appreciate hearing
about your experiences building applications with Obliv-C.&lt;/p&gt;

&lt;div class=&#34;credits&#34;&gt;
This tutorial was developed by Sam Havron, Nathaniel Grevatt, and David Evans.
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Obliv-C: A Language for Extensible Data-Oblivious Computation</title>
      <link>//oblivc.org/main/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//oblivc.org/main/</guid>
      <description>

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;//oblivc.org/images/oblivc-cropped.png&#34; align=&#34;center&#34; width=&#34;90%&#34;&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Obliv-C&lt;/strong&gt; is a simple GCC wrapper that makes it easy to embed secure
computation protocols inside regular C programs.&lt;/p&gt;

&lt;p&gt;The idea is simple: if you are performing a multi-party distributed
computation with sensitive data, just write it in our Obliv-C langauge
and compile/link it with your project. The result will be a secure
multi-party cryptographic protocol that performs this operation without
revealing any of the inputs or intermediate values of the computation to
any of the parties. Only the final outputs are revealed.&lt;/p&gt;

&lt;p&gt;This paper motivates and describes Obliv-C:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Samee Zahur and David Evans. &lt;a href=&#34;http://eprint.iacr.org/2015/1153.pdf&#34;&gt;&lt;em&gt;Obliv-C: A Language for Extensible
Data-Oblivious Computation&lt;/em&gt;&lt;/a&gt;,
&lt;a href=&#34;http://eprint.iacr.org/2015/1153&#34;&gt;Cryptology ePrint Archive: Report
2015:1153&lt;/a&gt;
[&lt;a href=&#34;http://eprint.iacr.org/2015/1153&#34;&gt;PDF&lt;/a&gt;], November 2015.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This mini-book provides an introduction to secure multi-party computation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;David Evans, Vladimir Kolesnikov and Mike Rosulek. &lt;a href=&#34;https://www.securecomputation.org/&#34;&gt;&lt;em&gt;A Pragmatic Introduction to Secure Multi-Party Computation&lt;/em&gt;&lt;/a&gt;, NOW Publishers, December 2018. [&lt;a href=&#34;https://www.securecomputation.org/docs/pragmaticmpc.pdf&#34;&gt;PDF&lt;/a&gt;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Code: &lt;a href=&#34;https://github.com/samee/obliv-c&#34;&gt;https://github.com/samee/obliv-c&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This repository includes the implementation of Obliv-C and several example applications and benchmarks.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;//oblivc.org/tutorial&#34;&gt;&lt;strong&gt;Tutorial&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Walks through how to install Obliv-C and build your first data-oblivious application using a simple linear regression example application.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;//oblivc.org/documentation&#34;&gt;&lt;strong&gt;Documentation&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Documentation on Obliv-C&amp;rsquo;s language extensions and library functions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;//oblivc.org/rust&#34;&gt;&lt;strong&gt;Rust Wrapper&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Calling Obliv-C protocols from Rust programs (&lt;a href=&#34;https://www.informatik.hu-berlin.de/de/Members/schopmaf/&#34;&gt;Phillipp
Schoppmann&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a name=&#34;projects&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;projects-using-obliv-c&#34;&gt;Projects Using Obliv-C&lt;/h2&gt;

&lt;p&gt;&lt;div class=&#34;row&#34;&gt;
   &lt;div class=&#34;column3&#34;&gt;&lt;/p&gt;

&lt;h3 id=&#34;libraries-and-protocols&#34;&gt;Libraries and Protocols&lt;/h3&gt;

&lt;p&gt;Fast Oblivious Memories:&lt;br /&gt;
&lt;a href=&#34;https://gitlab.com/neucrypt/floram&#34;&gt;&lt;strong&gt;floram&lt;/strong&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;//oblivc.org/sqoram&#34;&gt;&lt;strong&gt;SqORAM&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Cryptographic library:&lt;br /&gt;
&lt;a href=&#34;https://bitbucket.org/jackdoerner/absentminded-crypto-kit&#34;&gt;&lt;strong&gt;Absentminded Crypto Kit&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://mightbeevil.com/halfgates/&#34;&gt;&lt;strong&gt;Half-Gates&lt;/strong&gt;&lt;/a&gt;
   &lt;/div&gt;
   &lt;div class=&#34;column3&#34;&gt;&lt;/p&gt;

&lt;h3 id=&#34;applications&#34;&gt;Applications&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;//oblivc.org/ppml&#34;&gt;&lt;strong&gt;Distributed Learning&lt;/strong&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://eprint.iacr.org/2016/892&#34;&gt;Distributed Linear Regression&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;//oblivc.org/ppml&#34;&gt;MPC + Differential Privacy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;//oblivc.org/matching&#34;&gt;&lt;strong&gt;Secure Stable Matching&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;//oblivc.org/dca&#34;&gt;Decentralized CAs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Sub-String Search:&lt;br /&gt;
&lt;a href=&#34;https://github.com/jnayak1/kmp-mpc&#34;&gt;Oblivious Knuth-Morris-Pratt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;
   &lt;div class=&#34;column3&#34;&gt;&lt;/p&gt;

&lt;h3 id=&#34;applications-by-others&#34;&gt;Applications by Others&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/1806.03281&#34;&gt;Blind Justice: Fairness with Encrypted Sensitive Attributes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://eprint.iacr.org/2018/289.pdf&#34;&gt;Private Nearest Neighbors&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/bargavjayaraman/SecureDeepLearning&#34;&gt;Secure Deep Learning&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Multi-party data analytics: &lt;a href=&#34;https://arxiv.org/pdf/1902.06288.pdf&#34;&gt;&lt;strong&gt;Conclave&lt;/strong&gt;&lt;/a&gt; (EuroSys 2019)&lt;/p&gt;

&lt;p&gt;Encrypted email: &lt;a href=&#34;http://www.cs.nyu.edu/~mwalfish/papers/pretzel-sigcomm17.pdf&#34;&gt;&lt;strong&gt;Pretzel&lt;/strong&gt;&lt;/a&gt; (SIGCOMM 2017)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://calctopia.com&#34;&gt;SECCOMP - The Secure Spreadsheet&lt;/a&gt;, Calctopia, 2017.
   &lt;/div&gt;
   &lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;publications-and-talks&#34;&gt;Publications and Talks&lt;/h2&gt;

&lt;p&gt;&lt;div class=&#34;row&#34;&gt;
   &lt;div class=&#34;column&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;USENIX Sec 2019&lt;/strong&gt;: &lt;a href=&#34;//oblivc.org/docs/evaluatingdp.pdf&#34;&gt;&lt;em&gt;Evaluating Differentially Private Machine Learning in Practice&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NeurIPS 2018&lt;/strong&gt;: &lt;a href=&#34;//oblivc.org/docs/neurips2018.pdf&#34;&gt;&lt;em&gt;Distributed Learning without Distress:
Privacy-Preserving Empirical Risk Minimization&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PETS 2017&lt;/strong&gt;: &lt;a href=&#34;//oblivc.org/docs/distributedregression.pdf&#34;&gt;&lt;em&gt;Privacy-Preserving Distributed Linear Regression on High-Dimensional Data&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CCS 2016&lt;/strong&gt;: &lt;a href=&#34;http://oblivc.org/docs/matching.pdf&#34;&gt;&lt;em&gt;Secure Stable Matching at Scale&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;S&amp;amp;P 2016&lt;/strong&gt;: &lt;a href=&#34;//oblivc.org/docs/sqoram.pdf&#34;&gt;&lt;em&gt;Revisiting Square-Root ORAM Efficient
Random Access in Multi-Party Computation&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EuroCrypt 2015&lt;/strong&gt;: &lt;a href=&#34;//www.cs.virginia.edu/evans/pubs/ec2015/halfgates.pdf&amp;quot;&amp;gt;PDF&amp;lt;/a&#34;&gt;&lt;em&gt;Two Halves Make a Whole: Reducing Data Transfer in Garbled Circuits using Half Gates&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Obliv-C 2015&lt;/strong&gt;: &lt;a href=&#34;http://eprint.iacr.org/2015/1153.pdf&#34;&gt;&lt;em&gt;Obliv-C: A Language for Extensible
Data-Oblivious Computation&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;//oblivc.org/pubs&#34;&gt;Full publications list&amp;hellip;&lt;/a&gt;
   &lt;/div&gt;
   &lt;div class=&#34;column&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ECRYPT NET&lt;/strong&gt;: &lt;a href=&#34;https://www.jeffersonswheel.org/2017/secure-multi-party-computation-promises-protocols-and-practicalities&#34;&gt;&lt;em&gt;Secure Multi-Party Computation: Promises, Protocols, and Practicalities&lt;/em&gt;&lt;/a&gt; (Paris, 27 June 2017) [&lt;a href=&#34;https://speakerdeck.com/evansuva/secure-multi-party-computation-promises-protocols-and-practicalities&#34;&gt;SpeakerDeck&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Federal Trade Commission&lt;/strong&gt;: &lt;a href=&#34;https://www.jeffersonswheel.org/2016/ftc-visit&#34;&gt;&lt;em&gt;Private Data Analysis using Multi-Party Computation&lt;/em&gt;&lt;/a&gt; (joint presentation with Denis Nekipelov, 18 August 2016)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aarhus&lt;/strong&gt;: &lt;a href=&#34;https://www.jeffersonswheel.org/2016/aarhus-workshop-on-theory-and-practice-of-secure-multiparty-computation&#34;&gt;&lt;em&gt;From Mercury Delay Lines to Magnetic Core Memories: Progress in Oblivious Memories&lt;/em&gt;&lt;/a&gt; (&lt;a href=&#34;http://ctic.au.dk/events/workshops-conferences/mpc-2016/&#34;&gt;MPC Workshop&lt;/a&gt;, June 2016) [&lt;a href=&#34;https://speakerdeck.com/evansuva/from-mercury-delay-lines-to-magnetic-core-memories-progress-in-oblivious-memories&#34;&gt;Speaker Deck&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;iDash&lt;/strong&gt;: &lt;a href=&#34;http://www.humangenomeprivacy.org/2015/slides/UV.pdf&#34;&gt;&lt;em&gt;Obliv-C: A Simple C Extension for
SMC&lt;/em&gt;&lt;/a&gt; (Samee
Zahur&amp;rsquo;s talk at &lt;em&gt;iDash Privacy &amp;amp; Security Workshop&lt;/em&gt; 2015, won award
for fastest &amp;ldquo;Hamming Distance&amp;rdquo; execution)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CROSSING&lt;/strong&gt;: &lt;a href=&#34;http://www.cs.virginia.edu/~evans/talks/crossing2015/&#34;&gt;&lt;em&gt;Multi-Party Computation for the
Masses&lt;/em&gt;&lt;/a&gt;
(includes video) (CROSSING Conference, Darmstadt, June 2015)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;//oblivc.org/talks&#34;&gt;Full talks list&amp;hellip;&lt;/a&gt;
   &lt;/div&gt;
   &lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;people&#34;&gt;People&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://bargavjayaraman.github.io/&#34;&gt;Bargav Jayaraman&lt;/a&gt;, PhD Student&lt;br /&gt;
Nathaniel Grevatt, Undergraduate Researcher&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cs.virginia.edu/evans&#34;&gt;David Evans&lt;/a&gt;, Faculty Advisor&lt;/p&gt;

&lt;h3 id=&#34;alumni&#34;&gt;Alumni&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cs.virginia.edu/~sza4uq/&#34;&gt;&lt;strong&gt;Samee Zahur&lt;/strong&gt;&lt;/a&gt;, Project Founder and Leader (now at Google)&lt;br /&gt;
&lt;a href=&#34;http://darioncassel.me/&#34;&gt;Darion Cassel&lt;/a&gt;, Undergraduate Researcher (now at CMU)&lt;br /&gt;
&lt;a href=&#34;https://github.com/ndokmai&#34;&gt;Natnatee (&amp;ldquo;Ko&amp;rdquo;) Dokmai&lt;/a&gt;, Undergraduate Researcher (now at Indiana University)&lt;br /&gt;
&lt;a href=&#34;https://jackdoerner.net/&#34;&gt;Jack Doerner&lt;/a&gt;, Wizard of Oblivion (now at Northeastern)&lt;br /&gt;
&lt;a href=&#34;https://havron.xyz&#34;&gt;Samuel Havron&lt;/a&gt;, Undergraduate Researcher (now at Cornell)&lt;br /&gt;
&lt;a href=&#34;https://github.com/HainaLi&#34;&gt;Hannah Li&lt;/a&gt;, Undergraduate at Masters Student (now at Facebook)&lt;br /&gt;
&lt;a href=&#34;https://github.com/jnayak1&#34;&gt;Jesse Nayak&lt;/a&gt;, Undergraduate Researcher&lt;/p&gt;

&lt;p&gt;Other Notable Contributors:&lt;br /&gt;
&lt;a href=&#34;https://github.com/Lichard&#34;&gt;Richard Li&lt;/a&gt;, &lt;a href=&#34;https://github.com/mdh3hc&#34;&gt;Michael Mahoney&lt;/a&gt;, &lt;a href=&#34;https://github.com/wangxiao1254&#34;&gt;Xiao&amp;nbsp;Wang&lt;/a&gt;, &lt;a href=&#34;https://www.chenweikeng.com/&#34;&gt;Weikeng&amp;nbsp;Chen&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Privacy-Preserving Machine Learning</title>
      <link>//oblivc.org/ppml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//oblivc.org/ppml/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Distributed learning&lt;/em&gt; (sometimes known as &lt;em&gt;federated learning&lt;/em&gt;)
allows a group of independent data owners to collaboratively learn a
model over their data sets without exposing their private data.&lt;/p&gt;

&lt;p&gt;Our approach combines &lt;em&gt;differential privacy&lt;/em&gt; with secure &lt;em&gt;multi-party
computation&lt;/em&gt; to both protect the data during training and produce a
model that provides privacy against inference attacks.&lt;/p&gt;

&lt;p&gt;We explore two popular methods of differential privacy, output
perturbation and gradient perturbation, and advance the
state-of-the-art for both methods in the distributed learning
setting. In our output perturbation method, the parties combine local
models within a secure computation and then add therequired
differential privacy noise before revealing the model. In our gradient
perturbation method, the data owners collaboratively train a global
model via aniterative learning algorithm. At each iteration, the
parties aggregate their local gradients within a secure computation,
adding sufficient noise to ensure privacy before the gradient updates
are revealed. For both methods, we show that the noise can be reduced
in the multi-party setting by adding the noise inside the
securecomputation after aggregation, asymptotically improving upon the
best previous results. Experiments on real world data sets demonstrate
that our methods providesubstantial utility gains for typical privacy
requirements.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34;
    src=&#34;https://www.youtube-nocookie.com/embed/rwyWiDyVmjE&#34;
    frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media;
    gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/bargavj/distributedMachineLearning&#34;&gt;&lt;em&gt;&lt;a href=&#34;https://github.com/bargavj/distributedMachineLearning&#34;&gt;https://github.com/bargavj/distributedMachineLearning&lt;/a&gt;&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;papers&#34;&gt;Papers&lt;/h2&gt;

&lt;p&gt;Bargav Jayaraman, Lingxiao Wang, David Evans and Quanquan Gu. &lt;a href=&#34;//oblivc.org/docs/neurips2018.pdf&#34;&gt;&lt;em&gt;Distributed Learning without Distress:
Privacy-Preserving Empirical Risk Minimization&lt;/em&gt;&lt;/a&gt;. &lt;a href=&#34;https://nips.cc/Conferences/2018/&#34;&gt;32&lt;sup&gt;nd&lt;/sup&gt; Conference on Neural Information Processing Systems&lt;/a&gt; (NeurIPS). Montreal, Canada. December 2018. (&lt;a href=&#34;//oblivc.org/docs/neurips2018.pdf&#34;&gt;PDF&lt;/a&gt;, 12 pages) (&lt;a href=&#34;https://papers.nips.cc/paper/7871-distributed-learning-without-distress-privacy-preserving-empirical-risk-minimization&#34;&gt;NeurIPS Paper Page&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Lu Tian, Bargav Jayaraman, Quanquan Gu, and David Evans. &lt;a href=&#34;//oblivc.org/docs/pmpml.pdf&#34;&gt;&lt;em&gt;Aggregating
Private Sparse Learning Models Using Multi-Party Computation&lt;/em&gt;&lt;/a&gt;. In
&lt;a href=&#34;https://pmpml.github.io/PMPML16/&#34;&gt;Private Multi‑Party Machine Learning&lt;/a&gt;
(NIPS 2016 Workshop), Barcelona, 9 December 2016.  (&lt;a href=&#34;//oblivc.org/docs/pmpml.pdf&#34;&gt;PDF&lt;/a&gt;, 6 pages)&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;//oblivc.org/images/mpcaggregation.png&#34; width=650&gt;
&lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Revisiting Square Root ORAM</title>
      <link>//oblivc.org/sqoram/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//oblivc.org/sqoram/</guid>
      <description>

&lt;h2 id=&#34;efficient-random-access-in-multi-party-computation&#34;&gt;Efficient Random Access in Multi-Party Computation&lt;/h2&gt;

&lt;p&gt;Hiding memory access patterns is required for secure computation, but
remains prohibitively expensive for many interesting applications. Prior
work has either developed custom algorithms that minimize the need for
data-dependant memory access, or proposed the use of Oblivious RAM
(ORAM) to provide a general-purpose solution. However, most ORAMs are
designed for client-server scenarios, and provide only asymptotic
benefits in secure computation.&lt;/p&gt;

&lt;p&gt;We show how the classical square-root ORAM of Goldreich and Ostrovsky
can be modified to provide a practical ORAM for use in secure
computation, even though it is asymptotically worse than the best known
schemes. Specifically, we show a design that has over 100&lt;em&gt;x&lt;/em&gt; lower
initialization cost, and provides benefits over linear scan for just 8
blocks of data. Our scheme outperforms alternate approaches across a
wide range of parameters, often by several orders of magnitude.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;//oblivc.org/images/sqoramcompare.png&#34; align=&#34;center&#34; width=&#34;70%&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/samee/sqrtOram&#34;&gt;https://github.com/samee/sqrtOram&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This repository includes the implementation of Square-Root ORAM in
&lt;a href=&#34;//oblivc.org/&#34;&gt;Obliv-C&lt;/a&gt;, as well as several example applications and benchmarks.&lt;/p&gt;

&lt;h2 id=&#34;paper&#34;&gt;Paper&lt;/h2&gt;

&lt;p&gt;Samee Zahur, Xiao Wang, Mariana Raykova, Adrià Gascón, Jack Doerner,
David Evans, Jonathan Katz. &lt;a href=&#34;//oblivc.org/docs/sqoram.pdf&#34;&gt;&lt;em&gt;Revisiting Square-Root ORAM Efficient
Random Access in Multi-Party Computation&lt;/em&gt;&lt;/a&gt;. In &lt;a href=&#34;http://www.ieee-security.org/TC/SP2016/&#34;&gt;&lt;em&gt;37&lt;sup&gt;th&lt;/sup&gt; IEEE
Symposium on Security and
Privacy&lt;/em&gt;&lt;/a&gt; (&amp;ldquo;Oakland&amp;rdquo;). San
Jose, CA. 23-25 May 2016.&lt;/p&gt;

&lt;h2 id=&#34;people&#34;&gt;People&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cs.virginia.edu/~sza4uq/&#34;&gt;Samee Zahur&lt;/a&gt; (University of Virginia), Project Founder and Leader&lt;br /&gt;
&lt;a href=&#34;https://github.com/wangxiao1254&#34;&gt;Xiao Wang&lt;/a&gt; (University of Maryland)&lt;br /&gt;
&lt;a href=&#34;http://cpsc.yale.edu/people/mariana-raykova&#34;&gt;Mariana Raykova&lt;/a&gt; (Yale University)&lt;br /&gt;
&lt;a href=&#34;http://www.cs.upc.edu/~agascon/&#34;&gt;Adrià Gascón&lt;/a&gt; (University of Edinburgh)&lt;br /&gt;
&lt;a href=&#34;https://jackdoerner.net/&#34;&gt;Jack Doerner&lt;/a&gt; (University of Virginia)&lt;br /&gt;
&lt;a href=&#34;https://www.cs.virginia.edu/evans&#34;&gt;David Evans&lt;/a&gt; (University of Virginia)&lt;br /&gt;
&lt;a href=&#34;https://www.cs.umd.edu/~jkatz/&#34;&gt;Jonathan Katz&lt;/a&gt; (University of Maryland)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rust Wrapper for Obliv-C</title>
      <link>//oblivc.org/rust/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//oblivc.org/rust/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-Rust&#34;&gt;   unsafe { pd.exec_yao_protocol(millionaire, &amp;amp;mut args); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://www.informatik.hu-berlin.de/de/Members/schopmaf/&#34;&gt;Phillipp
Schoppmann&lt;/a&gt;
developed a Rust library for enabling Rust programs to integrate with
protocols implemented in Obliv-C.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/schoppmp/oblivc-rust&#34;&gt;https://github.com/schoppmp/oblivc-rust&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Secure Stable Matching at Scale</title>
      <link>//oblivc.org/matching/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//oblivc.org/matching/</guid>
      <description>

&lt;h2 id=&#34;secure-stable-matching-at-scale&#34;&gt;Secure Stable Matching at Scale&lt;/h2&gt;

&lt;p&gt;When a group of individuals and organizations wish to compute a &lt;em&gt;stable
matching&lt;/em&gt; &amp;mdash; for example, when medical students are matched to
medical residency programs &amp;mdash; they often outsource the computation
to a trusted arbiter to preserve the privacy of participants’ preference
rankings. Secure multi-party computation presents an alternative that
offers the possibility of private matching processes that do not rely on
any common trusted third party. However, stable matching algorithms are
computationally intensive and involve complex data-dependent memory
access patterns, so they have previously been considered infeasible for
execution in a secure multiparty context on non-trivial inputs.&lt;/p&gt;

&lt;p&gt;We adapt the classic Gale-Shapley algorithm for use in such a
context, and show experimentally that our modifications yield a
lower asymptotic complexity and more than an order of magnitude
in practical cost improvement over previous techniques. Our
main insights are to design new oblivious data structures that exploit
the properties of the matching algorithms. We then apply our
secure computation techniques to the instability chaining algorithm
of Roth and Peranson, currently in use by the National Resident
Matching Program. The resulting algorithm is efficient enough to
be useful at the scale required for matching medical residents nationwide,
taking just over 17 hours to complete an execution simulating
the 2016 NRMP match with more than 35,000 participants
and 30,000 residency slots.&lt;/p&gt;

&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jackdoerner/secure-stable-matching&#34;&gt;&lt;em&gt;https://github.com/jackdoerner/secure-stable-matching&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;paper&#34;&gt;Paper&lt;/h2&gt;

&lt;p&gt;Jack Doerner, David Evans, and abhi shelat. &lt;a href=&#34;//oblivc.org/docs/matching.pdf&#34;&gt;&lt;em&gt;Secure Stable Matching at
Scale&lt;/em&gt;&lt;/a&gt;.  In &lt;a href=&#34;https://www.sigsac.org/ccs/CCS2016/&#34;&gt;&lt;em&gt;23&lt;sup&gt;rd&lt;/sup&gt; ACM Conference on
Computer and Communications
Security&lt;/em&gt;&lt;/a&gt; (CCS). Vienna,
Austria. 24-28 October 2016.&lt;/p&gt;

&lt;h2 id=&#34;people&#34;&gt;People&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://jackdoerner.net/&#34;&gt;Jack Doerner&lt;/a&gt; (University of Virginia)&lt;br /&gt;
&lt;a href=&#34;https://www.cs.virginia.edu/evans&#34;&gt;David Evans&lt;/a&gt; (University of Virginia)&lt;br /&gt;
abhi shelat (Northeastern University)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>