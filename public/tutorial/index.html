<!DOCTYPE html>
<html xmlns="//www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

<head>
  <title>
    Obliv-C Tutorial // Obliv-C
  </title>

  <link href="//gmpg.org/xfn/11" rel="profile">
<meta http-equiv="content-type" content="text/html; charset=utf-8">


<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

<meta name="description" content="">
<meta name="keywords" content="">
<meta name="author" content="">
<meta name="generator" content="Hugo 0.87.0" />


  <meta property="og:title" content="Obliv-C Tutorial" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:locale" content="en_US" />
<meta property="og:url" content="//oblivc.org/tutorial/" />


  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/base-min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/pure-min.css">
  
  
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/grids-responsive-min.css">
  
  

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

  <link href='//fonts.googleapis.com/css?family=Open+Sans:400,400italic,200,100,700,300,500,600,800' rel='stylesheet' type='text/css'>
  <link href='//fonts.googleapis.com/css?family=Libre+Baskerville:400,700,400italic' rel='stylesheet' type='text/css'>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/rotunda.png">
  <link rel="shortcut icon" href="/rotunda.png">

    
  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/tomorrow-night-bright.min.css">
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>


  <link rel="stylesheet" href="//oblivc.org/css/srg.css">

  

  

  
</head>

<body>
	

	<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
  <div class="header">
    <h2 class="brand-group">
<a href="http://www.jeffersonswheel.org">Security Research Group</a><br>
<a href="http://www.cs.virginia.edu">University of Virginia</a>
</h2>



<a href="//oblivc.org"><img src="/images/oblivc-small.png" align="center" width="90%"></a>

    <h2 class="brand-tagline">
A Language for Extensible Data&#8209;Oblivious Computation
   </h2>






    

  </div>
</div>

	
	

    <div class="content pure-u-1 pure-u-md-3-4">
		<a name="top"></a>
		

		
  		<section class="post">
            <h1 class="post-title">
              <a href="/tutorial/">Obliv-C Tutorial</a>
            </h1>
            <h3 class="post-subtitle">
            	
            </h3>
            
            
            	
            

			
			

			

			

            <p>Obliv-C is a simple GCC wrapper that makes it easy to embed secure
computation protocols inside regular C programs. This tutorial
explains how to set up and build your first Obliv-C program using
privacy-preserving linear regression application as an example.</p>
<h2 id="installation">Installation</h2>
<h4 id="1-install-dependencies">1. Install Dependencies</h4>
<p>Before setting up Obliv-C, several other modules need to be installed. Here are the commands to do the installations, depending on your platform.</p>
<p>Ubuntu:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#960050;background-color:#1e0010">$</span> sudo apt install ocaml libgcrypt20<span style="color:#f92672">-</span>dev ocaml<span style="color:#f92672">-</span>findlib
</code></pre></div><p>Fedora:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#960050;background-color:#1e0010">$</span> sudo dnf install glibc<span style="color:#f92672">-</span>devel.i686 ocaml ocaml<span style="color:#f92672">-</span>ocamldoc ocaml<span style="color:#f92672">-</span>findlib ocaml<span style="color:#f92672">-</span>findlib<span style="color:#f92672">-</span>devel libgcrypt libgcrypt<span style="color:#f92672">-</span>devel perl<span style="color:#f92672">-</span>ExtUtils<span style="color:#f92672">-</span>MakeMaker perl<span style="color:#f92672">-</span>Data<span style="color:#f92672">-</span>Dumper
</code></pre></div><p>Mac OS (with Macports):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#960050;background-color:#1e0010">$</span> sudo port install gcc5 ocaml ocaml<span style="color:#f92672">-</span>findlib libgcrypt <span style="color:#f92672">+</span>devel
</code></pre></div><h4 id="2-cloning-obliv-c">2. Cloning Obliv-C</h4>
<p>Clone the <a href="https://github.com/samee/obliv-c">Obliv-C source repository</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ git clone https://github.com/samee/obliv-c
</code></pre></div><h4 id="3-build-obliv-c">3. Build Obliv-C</h4>
<p>Linux:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#960050;background-color:#1e0010">$</span> .<span style="color:#f92672">/</span>configure <span style="color:#f92672">&amp;&amp;</span> make
</code></pre></div><p>Mac OS:</p>
<p>First, you need to install <a href="https://guide.macports.org/chunked/installing.macports.html">MacPorts</a>.  Then,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ CC=/opt/local/bin/gcc-mp-5 CPP=/opt/local/bin/cpp-mp-5 LIBRARY_PATH=/opt/local/lib ./configure <span style="color:#960050;background-color:#1e0010">&amp;&amp;</span> make
</code></pre></div><p>You&rsquo;re all set!</p>
<p>The compiler is a GCC wrapper script found in <code>bin/oblivcc</code>.  Example programs are in <code>test/oblivc</code>.</p>
<h2 id="understanding-obliv-c-programs">Understanding Obliv-C Programs</h2>
<p>Here, we explain how an Obliv-C program works in four steps. For this tutorial, we implement a sample linear regression in Obliv-C: <a href="https://github.com/samee/obliv-c/tree/obliv-c/test/oblivc/linreg">https://github.com/samee/obliv-c/tree/obliv-c/test/oblivc/linreg</a>.</p>
<p>This example is for instructional purposes only, and does not take
advantage of all features of Obliv-C and favors simplicity over
performance.</p>
<h3 id="1-connecting-parties-storing-arguments-and-executing-yaos-protocol">1. Connecting parties, storing arguments, and executing Yao&rsquo;s protocol</h3>
<p>The protocol is started in <code>main()</code> in
<a href="https://github.com/samee/obliv-c/blob/obliv-c/test/oblivc/linreg/linreg.c">linreg.c</a>. The
<code>#include &lt;obliv.h&gt;</code> header is needed to incorporate the Obliv-C library.</p>
<p>The first step to creating a protocol is to initialize a
<code>ProtocolDesc</code> object, stored in the <code>pd</code> variable in this code. This
is needed as an argument for several essential functions.</p>
<p>After storing the command-line arguments (hostname, TCP port, party,
and data filename) to <code>protocolIO io</code> (a struct defined in
<a href="https://github.com/samee/obliv-c/blob/obliv-c/test/oblivc/linreg/linreg.h">linreg.h</a>),
a connection must be established between the two parties.  The
<code>ProtocolDesc</code> structure is a convenient way to represent
data used in both your C and Obliv-C files.</p>
<h4 id="connecting-parties">Connecting Parties</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// code ...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>remote_host <span style="color:#f92672">=</span> strtok(argv[<span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;:&#34;</span>); <span style="color:#75715e">// parse hostname from cmdline
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>port <span style="color:#f92672">=</span> strtok(NULL, <span style="color:#e6db74">&#34;:&#34;</span>); <span style="color:#75715e">// parse port name from cmdline
</span><span style="color:#75715e"></span>ProtocolDesc pd;
protocolIO io;
<span style="color:#75715e">// code ...
</span><span style="color:#75715e"></span>log_info(<span style="color:#e6db74">&#34;Connecting to %s on port %s ...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, remote_host, port);
<span style="color:#66d9ef">if</span>(argv[<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span>) {
   <span style="color:#66d9ef">if</span>(protocolAcceptTcp2P(<span style="color:#f92672">&amp;</span>pd,port)<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>) {
      log_err(<span style="color:#e6db74">&#34;TCP accept from %s failed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, remote_host);
      exit(<span style="color:#ae81ff">1</span>);
   }
} <span style="color:#66d9ef">else</span> {
   <span style="color:#66d9ef">if</span>(protocolConnectTcp2P(<span style="color:#f92672">&amp;</span>pd,remote_host,port)<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>) {
      log_err(<span style="color:#e6db74">&#34;TCP connect to %s failed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, remote_host);
      exit(<span style="color:#ae81ff">1</span>);
   }
}
<span style="color:#75715e">// code ...
</span><span style="color:#75715e"></span>cp <span style="color:#f92672">=</span> (argv[<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;1&#39;</span><span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>);
setCurrentParty(<span style="color:#f92672">&amp;</span>pd, cp); <span style="color:#75715e">// only checks for a &#39;1&#39;
</span><span style="color:#75715e"></span>io.src <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">3</span>]; <span style="color:#75715e">// filename
</span></code></pre></div><p>The first party calls <code>protocolAcceptTcp2P()</code> to listen for a connection. The
<code>log_err()</code> function is defined for this example in <a href="https://github.com/samee/obliv-c/blob/obliv-c/test/oblivc/linreg/dbg.h">dbg.h</a>.</p>
<p>The important takeaway from the above code snippet is that the accept
and connect functions were called by the appropriate parties). Then,
the second party calls <code>protocolConnectTcp2P()</code>, supplying the
hostname from the commandline argument and connecting to the first
party. After a connection is made, <code>setCurrentParty()</code> is called,
which allows the <code>ProtocolDesc pd</code> to keep track of parties.</p>
<h4 id="executing-yaos-protocol">Executing Yao&rsquo;s Protocol</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// Execute Yao protocol and cleanup
</span><span style="color:#75715e"></span>execYaoProtocol(<span style="color:#f92672">&amp;</span>pd, linReg, <span style="color:#f92672">&amp;</span>io);
cleanupProtocol(<span style="color:#f92672">&amp;</span>pd);
</code></pre></div><p>Now, <code>execYaoProtocol()</code> is called; this function begins linReg.oc&rsquo;s code at the supplied function name: linReg().</p>
<h3 id="2-loading-local-data-and-sharing-obliv-qualified-data">2. Loading local data and sharing obliv qualified data</h3>
<p>Now, we switch to the Olbiv-C code in <a href="https://github.com/samee/obliv-c/blob/obliv-c/test/oblivc/linreg/linreg.oc"><code>linreg.oc</code></a>. Code in the <code>.oc</code> files can use the <code>obliv</code> extensions, and it source-to-source translacted to C code as part of the Obliv-C compilation process.</p>
<p>Loading local data and obtaining <code>protocolIO</code> struct values in Obliv-C
is done inside the <code>void linReg()</code> function, called by
<code>execYaoProtocol()</code> at the end of step 1:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">protocolIO <span style="color:#f92672">*</span>io <span style="color:#f92672">=</span> (protocolIO<span style="color:#f92672">*</span>) args;

<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>x <span style="color:#f92672">=</span> malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> ALLOC);
<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>y <span style="color:#f92672">=</span> malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> ALLOC);
<span style="color:#75715e">// code ...
</span><span style="color:#75715e"></span>load_data(io, <span style="color:#f92672">&amp;</span>x, <span style="color:#f92672">&amp;</span>y, ocCurrentParty());
</code></pre></div><p>Notice that the struct used for accessing variables across C and Obliv-C files (<code>protocolIO io</code>)
is obtained from the call to <code>linReg()</code> by <code>execYaoProtocol()</code>.</p>
<p>To load the data points (the private input) from local files for each
party, two int arrays were created with <code>ALLOC</code> being an initial size
defined in
<a href="https://github.com/samee/obliv-c/blob/obliv-c/test/oblivc/linreg/linreg.h"><code>linreg.h</code></a>.
The <code>load_data()</code> function from
<a href="https://github.com/samee/obliv-c/blob/obliv-c/test/oblivc/linreg/linreg.c"><code>linreg.c</code></a>
is called, with the int arrays created in the Obliv-C file being
passed in as parameters.</p>
<p><em>Note that calls can be
made to C file functions even while being in Yao&rsquo;s protocol and
running code in an Obliv-C file</em>.  The majority of the <code>load_data()</code>
function is comprised of regular C procedures, with the exception of
this code snippet:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">float</span> a_float <span style="color:#f92672">=</span> (<span style="color:#66d9ef">float</span>) a;
<span style="color:#66d9ef">if</span> (party <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
   <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>x <span style="color:#f92672">+</span> io<span style="color:#f92672">-&gt;</span>n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span>  a_float; <span style="color:#75715e">// messy, but needed for dereferencing 
</span><span style="color:#75715e"></span>} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (party <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) {
   <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>y <span style="color:#f92672">+</span> io<span style="color:#f92672">-&gt;</span>n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span>  a_float;
}
</code></pre></div><h4 id="sharing-obliv-data">Sharing <code>obliv</code> data</h4>
<p>Now that the data for each party is stored locally in float arrays,
the data must be made oblivious (converted to <code>obliv</code>-typed data) and
then shared with the other party as private data:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// code ...
</span><span style="color:#75715e"></span>check_input_count(io);

obliv <span style="color:#66d9ef">float</span> <span style="color:#f92672">*</span>ox <span style="color:#f92672">=</span> malloc(<span style="color:#66d9ef">sizeof</span>(obliv <span style="color:#66d9ef">float</span>) <span style="color:#f92672">*</span> io<span style="color:#f92672">-&gt;</span>n);
obliv <span style="color:#66d9ef">float</span> <span style="color:#f92672">*</span>oy <span style="color:#f92672">=</span> malloc(<span style="color:#66d9ef">sizeof</span>(obliv <span style="color:#66d9ef">float</span>) <span style="color:#f92672">*</span> io<span style="color:#f92672">-&gt;</span>n);
    
toObliv(io, ox, x, <span style="color:#ae81ff">1</span>);
toObliv(io, oy, y, <span style="color:#ae81ff">2</span>);
</code></pre></div><p>Two new float arrays that are <code>obliv</code> qualified are created, with size
<code>io-&gt;n</code> after loading the local data (note that the call to
<code>check_input_count()</code> ensures both parties sent the same amount of
data using the <code>ocBroadcastFloat()</code> function). Then, <code>toObliv()</code> is
called:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// code ...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">toObliv</span>(protocolIO <span style="color:#f92672">*</span>io, obliv <span style="color:#66d9ef">float</span> <span style="color:#f92672">*</span>oa, <span style="color:#66d9ef">float</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">int</span> party) 
{
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> io<span style="color:#f92672">-&gt;</span>n; i<span style="color:#f92672">++</span>) {
        oa[i] <span style="color:#f92672">=</span> feedOblivFloat(a[i], party);
    }
}
</code></pre></div><p>The call to <code>feedOblivFloat()</code> (see <a href="../documentation">documentation</a>)
allows both parties to share their data over their network connection
as <code>obliv</code> qualified values.</p>
<p>The loop in <code>toObliv()</code> goes through each value in each party&rsquo;s
respective array.  You may notice that while both parties call
<code>toObliv()</code> twice, the party from which the local float array is
selected is hardcoded into the function call, so as to prevent party 1
from trying to convert its own y array data (which are all 0 because
nothing was ever stored to them) into <code>obliv</code> values, and vice versa.</p>
<h3 id="3-computing-linear-regression">3. Computing linear regression</h3>
<h4 id="computing-the-function-of-two-parties-linear-regression">Computing the function of two parties (linear regression)</h4>
<p>Our data has been shared obliviously into two arrays, and we are now
ready to perform our joint function on our private data (linear
regression). The code is very similar to what would be done in a
non-private implementation using standard C, except for the use of
<code>obliv</code> type qualifiers for the oblivious data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// code ...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> io<span style="color:#f92672">-&gt;</span>n;
obliv <span style="color:#66d9ef">float</span> sumx <span style="color:#f92672">=</span> sum(ox, n); <span style="color:#75715e">// sum of x
</span><span style="color:#75715e"></span>obliv <span style="color:#66d9ef">float</span> sumxx <span style="color:#f92672">=</span> dotProd(ox, ox, n); <span style="color:#75715e">// sum of each x squared
</span><span style="color:#75715e"></span>obliv <span style="color:#66d9ef">float</span> sumy <span style="color:#f92672">=</span> sum(oy, n); <span style="color:#75715e">// sum of y
</span><span style="color:#75715e"></span>obliv <span style="color:#66d9ef">float</span> sumyy <span style="color:#f92672">=</span> dotProd(oy, oy, n); <span style="color:#75715e">// sum of each y squared
</span><span style="color:#75715e"></span>obliv <span style="color:#66d9ef">float</span> sumxy <span style="color:#f92672">=</span> dotProd(ox, oy, n); <span style="color:#75715e">// sum of each x * y
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Compute least-squares best fit straight line
</span><span style="color:#75715e"></span>om <span style="color:#f92672">=</span> (n <span style="color:#f92672">*</span> sumxy <span style="color:#f92672">-</span> (sumx <span style="color:#f92672">*</span> sumy)) <span style="color:#f92672">/</span> (n <span style="color:#f92672">*</span> sumxx <span style="color:#f92672">-</span> osqr(sumx)); <span style="color:#75715e">// slope
</span><span style="color:#75715e"></span>ob <span style="color:#f92672">=</span> ((sumy <span style="color:#f92672">*</span> sumxx) <span style="color:#f92672">-</span> (sumx <span style="color:#f92672">*</span> sumxy)) <span style="color:#f92672">/</span> (n <span style="color:#f92672">*</span> sumxx <span style="color:#f92672">-</span> osqr(sumx)); <span style="color:#75715e">// y-intercept
</span><span style="color:#75715e"></span>
obliv <span style="color:#66d9ef">float</span> ocov <span style="color:#f92672">=</span> (n <span style="color:#f92672">*</span> sumxy) <span style="color:#f92672">-</span> (sumx <span style="color:#f92672">*</span> sumy);
obliv <span style="color:#66d9ef">float</span> ostddevs <span style="color:#f92672">=</span> ((n <span style="color:#f92672">*</span> sumxx) <span style="color:#f92672">-</span> osqr(sumx)) <span style="color:#f92672">*</span> ((n <span style="color:#f92672">*</span> sumyy) <span style="color:#f92672">-</span> osqr(sumy));
obliv <span style="color:#66d9ef">float</span> orsqr <span style="color:#f92672">=</span> osqr(ocov) <span style="color:#f92672">*</span> ostddevs; <span style="color:#75715e">// sqrt(revealed rsqr) = r
</span></code></pre></div><p>The <code>sum()</code> and <code>dotProd()</code> function allow us to obtain summations
that we need in order to compute our three (oblivious) results: <code>om</code> (slope),
<code>ob</code> (obliv y-intercept), and <code>orsqr</code> (correlation squared).</p>
<p>We then use these summations to calculate our results, which will be
revealed at the end of the protocol execution.</p>
<h3 id="4-revealing-results-cleaning-up">4. Revealing results, cleaning up</h3>
<h4 id="revealing-results">Revealing Results</h4>
<p>The <code>revealOblivFloat</code> function is used to reveal the oblivious
results to both parties. The first parameter is the location where the
non-obliv result value is to be stored, a field in the <code>protocolIO io</code> struct. The second parameter is the <code>obliv</code> result that will be revealed and stored into that location. Lastly, &lsquo;0&rsquo; specifies that all parties
will receive the result (alternatively a non-zero value could be used to reveal the result to just one of the paries).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">revealOblivFloat(<span style="color:#f92672">&amp;</span>io<span style="color:#f92672">-&gt;</span>rsqr, orsqr, <span style="color:#ae81ff">0</span>);
revealOblivFloat(<span style="color:#f92672">&amp;</span>io<span style="color:#f92672">-&gt;</span>m, om, <span style="color:#ae81ff">0</span>);
revealOblivFloat(<span style="color:#f92672">&amp;</span>io<span style="color:#f92672">-&gt;</span>b, ob, <span style="color:#ae81ff">0</span>);
</code></pre></div><h4 id="cleaning-up-recording-runtime-information">Cleaning up, recording runtime information</h4>
<p>Having stored the results as non-obliv floats in the <code>io</code> struct, we are now ready
to complete Yao&rsquo;s protocol and print our results to the Terminal.</p>
<p>After freeing our <code>float</code> arrays and <code>obliv float</code> arrays, <code>linReg()</code> finishes,
and as a result <code>execYaoProtocol()</code>, from
<a href="https://github.com/samee/obliv-c/blob/obliv-c/test/oblivc/linreg/linreg.c">linreg.c</a>,
completes execution as well.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// Execute Yao&#39;s protocol and cleanup
</span><span style="color:#75715e"></span>execYaoProtocol(<span style="color:#f92672">&amp;</span>pd, linReg, <span style="color:#f92672">&amp;</span>io);
cleanupProtocol(<span style="color:#f92672">&amp;</span>pd);
<span style="color:#75715e">// code ...
</span><span style="color:#75715e"></span>
log_info(<span style="color:#e6db74">&#34;Slope   </span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">m = %15.6e</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, io.m); <span style="color:#75715e">// print slope
</span><span style="color:#75715e"></span>log_info(<span style="color:#e6db74">&#34;y-intercept</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">b = %15.6e</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, io.b); <span style="color:#75715e">// print y-intercept
</span><span style="color:#75715e"></span>log_info(<span style="color:#e6db74">&#34;Correlation</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">r = %15.6e</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, sqrt(io.rsqr)); <span style="color:#75715e">// print correlation
</span></code></pre></div><p>To conclude, <code>cleanupProtocol()</code>, serving a similar purpose to use of <code>free()</code>
after calling <code>malloc()</code> on a given variable.
(Another useful built in function
to Obliv-C is <code>yaoGateCount()</code>, which gives the number gates executed in the protocol). Finally, we print our results from the linear regression.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We hope that this tutorial of how to implement linear regression
in Obliv-C will be a useful guide for starting to write
your own Obliv-C programs!  You&rsquo;ll find many more example Obliv-C programs in the repository as well as the other repositories linked for other <a href="/#projects">Obliv-C Projects</a>.</p>
<p>Please let us know if you have any suggestions for improving Obliv-C
or this tutorial.  We also welcome issues and pull requests to the
<a href="https://github.com/samee/obliv-c">Obliv-C repository</a> and deeply appreciate hearing
about your experiences building applications with Obliv-C.</p>
<!-- raw HTML omitted -->

	
			

			

			
          </section>
          
          	
          
        
      <div class="footer">
	<hr class="thin" />

-   <div class="funding">
This work has been supported by grants from the National Science Foundation SaTC Program.
   </div>

	<p></p>
</div>

    </div>
  </div>
	

	

  
</body>
</html>
